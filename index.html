<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Surf Lime</title>
  <style>
    :root { --bg:#0b1320; --ink:#e8f1ff; --accent:#46e38a; }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:#0b1320;color:var(--ink);font:14px/1.5 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    canvas{
      position:fixed; inset:0; width:100vw; height:100vh; display:block; background:#0a2846;
      touch-action:none; -ms-touch-action:none; user-select:none; -webkit-user-select:none;
    }
    .icon-row{ position:fixed; top:12px; right:12px; z-index:20; display:flex; gap:10px; }
    .icon-btn{
      display:inline-flex; align-items:center; justify-content:center;
      min-width:40px; height:40px; padding:0 12px; gap:8px;
      border-radius:12px; border:1px solid #ffffff22; background:#0f233caa;
      backdrop-filter:blur(6px); cursor:pointer; color:#fff; text-decoration:none;
      font-weight:600; letter-spacing:.2px;
    }
    .icon-btn:hover{ background:#122c4bee }
    .icon-btn svg{ width:20px; height:20px }
    /* Hide Settings text on mobile (coarse pointer) */
    @media (pointer: coarse) {
      .settings-label { display:none; }
    }
  </style>
</head>
<body>
  <canvas id="game" width="1024" height="576"></canvas>

  <div class="icon-row">
    <!-- Pause button -->
    <button id="btnPause" class="icon-btn" title="Start" aria-label="Start">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
           stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" id="pauseIcon">
        <rect x="6" y="4" width="4" height="16"></rect>
        <rect x="14" y="4" width="4" height="16"></rect>
      </svg>
      <span id="pauseLabel">Start</span>
    </button>

    <!-- Mute -->
    <button id="btnMute" class="icon-btn" title="Mute" aria-label="Mute">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
           stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
        <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
        <line x1="23" y1="9" x2="17" y2="15"></line>
        <line x1="17" y1="9" x2="23" y2="15"></line>
      </svg>
      <span>Mute</span>
    </button>

    <!-- Settings -->
    <a class="icon-btn" href="settings.html" title="Settings" aria-label="Settings">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
        <path d="M12 15.5a3.5 3.5 0 1 0 0-7 3.5 3.5 0 0 0 0 7z"/>
        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 1 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 1 1-4 0v-.09a1.65 1.65 0 0 0-1-1.51 1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 1 1-2.83-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 1 1 0-4h.09a1.65 1.65 0 0 0 1.51-1 1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 1 1 2.83-2.83l.06.06a1.65 1.65 0 0 0 1.82.33h0A1.65 1.65 0 0 0 9 3.09V3a2 2 0 1 1 4 0v.09a1.65 1.65 0 0 0 1 1.51h0a1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 1 1 2.83 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82h0A1.65 1.65 0 0 0 20.91 11H21a2 2 0 1 1 0 4h-.09a1.65 1.65 0 0 0-1.51 1z"/>
      </svg>
      <span class="settings-label">Settings</span>
    </a>
  </div>

  <script src="config.js"></script>
  <script>
  (()=>{
    const IS_MOBILE = (window.matchMedia && matchMedia('(pointer: coarse)').matches) || 'ontouchstart' in window;

    // ----- Pause button -----
    const pauseBtn = document.getElementById('btnPause');
    const pauseLbl = document.getElementById('pauseLabel');
    function setPauseUI(text){ 
      if(!pauseBtn) return; 
      pauseLbl.textContent = text; pauseBtn.title = text;
      const svg = pauseBtn.querySelector('#pauseIcon');
      if(svg){
        svg.innerHTML = (text==='Pause') 
          ? '<rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect>'
          : '<polygon points="8 5 19 12 8 19 8 5"></polygon>';
      }
    }
    function updatePauseUI(){ 
      if(state===STATE.RUN) setPauseUI('Pause');
      else if(state===STATE.PAUSE) setPauseUI('Resume');
      else setPauseUI('Start');
    }
    if(pauseBtn){
      pauseBtn.addEventListener('click', (e)=>{
        e.preventDefault();
        if(state===STATE.RUN) pause();
        else if(state===STATE.PAUSE) resume();
        else start();
        updatePauseUI();
      });
    }

    // ----- Mute button -----
    const muteBtn = document.getElementById('btnMute');
    function updateMuteUI(){
      if(!muteBtn) return;
      muteBtn.querySelector('span').textContent = muted ? 'Unmute' : 'Mute';
      muteBtn.title = muted ? 'Unmute' : 'Mute';
    }
    if(muteBtn){
      muteBtn.addEventListener('click',(e)=>{ e.preventDefault(); toggleMute(); updateMuteUI(); });
      setTimeout(updateMuteUI, 0);
    }

    // ----- Config helpers -----
    const CFG = window.SURFLIME_CONFIG || { };
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const lerp=(a,b,t)=>a+(b-a)*t;

    // ----- Supabase music URLs (if enabled) -----
    function getSupabaseMusicUrls(){
      const s = CFG.music && CFG.music.supabase;
      if(!s || !s.enabled || !s.projectRef || !s.bucket || !Array.isArray(s.files)) return null;
      const base = `https://${s.projectRef}.supabase.co/storage/v1/object/public/${encodeURIComponent(s.bucket)}/`;
      return s.files.map(name => base + encodeURIComponent(name));
    }
    const TRACKS = getSupabaseMusicUrls() || ['./Music/Surfing.mp3','./Music/Surfing2.mp3','./Music/Surfing3.mp3'];

    function getSelectedTrackUrl(urls){
      try{
        const saved = localStorage.getItem('musicSelectedUrl');
        if(saved && urls.includes(saved)) return saved;
      } catch {}
      return urls[(Math.random()*urls.length)|0];
    }

    // ----- Audio -----
    let music=null, waves=null, muted=false, audioUnlocked=false;
    function initMusic(){
      if(!music){
        const src = getSelectedTrackUrl(TRACKS);
        music = new Audio(src);
        music.loop = true; music.preload = 'auto'; music.playsInline = true;
      }
    }
    function initWaves(){
      if(!waves){
        waves = new Audio(); waves.loop = true; waves.preload = 'auto'; waves.playsInline = true;
      }
    }
    async function unlockAudio(){
      if(audioUnlocked) return;
      audioUnlocked = true;
      initMusic(); initWaves();
      try { music.muted = true; await music.play(); } catch(_) {}
      try {
        for(const p of ['./Sfx/Waves.mp3','./Music/Waves.mp3']){
          try { waves.muted = true; waves.src = p; await waves.play(); break; } catch(_) {}
        }
      } catch(_) {}
      queueMicrotask(()=>{
        music.muted = muted; music.volume = muted ? 0 : 0.35;
        const vol = Number.isFinite(CFG.audio?.wavesVolume) ? CFG.audio.wavesVolume : 0.25;
        waves.muted = muted; waves.volume = muted ? 0 : vol;
      });
    }
    function startMusic(){ initMusic(); music.muted = muted; music.volume = muted ? 0 : 0.35; music.play().catch(()=>{}); }
    function startWaves(){
      initWaves();
      const tryPaths = ['./Sfx/Waves.mp3','./Music/Waves.mp3'];
      let i=0;
      const tryNext = async ()=>{
        if(i>=tryPaths.length) return;
        waves.src = tryPaths[i++];
        try { await waves.play(); } catch { tryNext(); }
      };
      const vol = Number.isFinite(CFG.audio?.wavesVolume) ? CFG.audio.wavesVolume : 0.25;
      waves.muted = muted; waves.volume = muted ? 0 : vol; tryNext();
    }
    function toggleMute(){
      muted=!muted;
      if(music){ music.muted = muted; music.volume = muted ? 0 : 0.35; }
      if(waves){ const vol = Number.isFinite(CFG.audio?.wavesVolume) ? CFG.audio.wavesVolume : 0.25;
        waves.muted = muted; waves.volume = muted ? 0 : vol; }
    }
    window.addEventListener('storage', (e)=>{
      if(e.key==='musicSelectedUrl' && music){
        const u = localStorage.getItem('musicSelectedUrl');
        if(u){ music.src = u; if(state===STATE.RUN) music.play().catch(()=>{}); }
      }
    });

    document.addEventListener('pointerdown', unlockAudio, { once:true });
    document.addEventListener('keydown', unlockAudio, { once:true });

    // ----- Canvas -----
    const canvas=document.getElementById('game'); const ctx=canvas.getContext('2d',{alpha:false});
    let vw = canvas.width, vh = canvas.height, dpr=1;
    const world = { time: 0, seaLevel: 0 };
    function resizeDPR(){
      const rect = canvas.getBoundingClientRect();
      vw = Math.max(1, Math.round(rect.width));
      vh = Math.max(1, Math.round(rect.height));
      dpr = Math.max(1, window.devicePixelRatio || 1);
      canvas.width = Math.round(vw * dpr);
      canvas.height = Math.round(vh * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      world.seaLevel = vh * 0.58;
    }
    addEventListener('resize', resizeDPR);
    addEventListener('focus', ()=>{ applyPlayerSelections(); applyUserScaleToPlayers(); updatePauseUI(); });
    resizeDPR();

    function topLimitPx(){   const p=(CFG.limits?.topPercent??0.20);   return vh * Math.min(0.98, Math.max(0, p)); }
    function bottomLimitPx(){
      const p = (CFG.limits?.bottomPercent ?? 0.80);
      const desiredPx = vh * Math.min(0.999, Math.max(0, p));
      return Math.min(vh * 0.999, Math.max(topLimitPx() + 0.02*vh, desiredPx));
    }

    // ----- Scaling helpers -----
    function obstacleScaleMul(){
      const desk = Number.isFinite(CFG.obstacle?.scalePercent) ? CFG.obstacle.scalePercent : 100;
      const shrinkPct = Number.isFinite(CFG.mobile?.scaleDownPercent?.obstacle) ? CFG.mobile.scaleDownPercent.obstacle : null;
      const derivedMobile = Number.isFinite(CFG.obstacle?.scalePercentMobile)
        ? CFG.obstacle.scalePercentMobile
        : (shrinkPct!=null ? desk * (1 - clamp(shrinkPct,0,100)/100) : desk);
      const p = IS_MOBILE ? derivedMobile : desk;
      return Math.max(0.1, Math.min(3, p / 100));
    }
    function depthMul(kind,y){
      const top = topLimitPx(), bottom = bottomLimitPx();
      const t = (bottom>top) ? Math.max(0, Math.min(1, (y-top)/(bottom-top))) : 0;
      const d = CFG.depth?.[kind] || { topScale:1, bottomScale:1 };
      return lerp(d.topScale??1, d.bottomScale??1, t);
    }
    function applyUserScaleToPlayers(){
      const desktop = Number.isFinite(CFG.mascot?.scale) ? CFG.mascot.scale : 1;
      const shrinkPct = Number.isFinite(CFG.mobile?.scaleDownPercent?.mascot) ? CFG.mobile.scaleDownPercent.mascot : null;
      const derivedMobile = Number.isFinite(CFG.mascot?.scaleMobile)
        ? CFG.mascot.scaleMobile
        : (shrinkPct!=null ? desktop * (1 - clamp(shrinkPct,0,100)/100) : desktop);
      const s = IS_MOBILE ? derivedMobile : desktop;
      (players||[]).forEach(p=> p.USER_SCALE = s);
    }

    // ----- Players & input -----
    function assetsFor(name){
      if(CFG.mascot?.assetsFor) return CFG.mascot.assetsFor(name);
      const SURFER=new Set(['Banana','Pineapple']);
      const base=`./Mascots/${name}/${name}`;
      return { surf:`${base}${SURFER.has(name)?'Surfer':'Surf'}.png`, fall:`${base}Fall.png` };
    }
    function twoPlayerEnabled(){ return localStorage.getItem('twoPlayerEnabled') === 'true'; }
    function setTwoPlayer(val){ localStorage.setItem('twoPlayerEnabled', val ? 'true' : 'false'); }
    function selectedFor(idx){
      const key = (idx===0) ? 'selectedMascotP1' : 'selectedMascotP2';
      let name = localStorage.getItem(key);
      if(!name){
        name = (idx===0) ? 'Lime' : 'Banana';
        localStorage.setItem(key, name);
        if(idx===0) localStorage.setItem('selectedMascot', name);
      }
      return name;
    }

    const targetMascotH=112;
    const INPUT = [ { up:false, down:false, boost:false }, { up:false, down:false, boost:false } ];

    // Desktop keyboard controls
    addEventListener('keydown', e=>{
      if(e.code==='ArrowUp')INPUT[0].up=true;
      if(e.code==='ArrowDown')INPUT[0].down=true;
      if(e.code==='ArrowRight')INPUT[0].boost=true;
      if(e.code==='KeyW')INPUT[1].up=true;
      if(e.code==='KeyS')INPUT[1].down=true;
      if(e.code==='KeyD')INPUT[1].boost=true;
      if(e.code==='KeyM')toggleMute();
      if(e.code==='Enter' || e.code==='NumpadEnter'){
        if(state===STATE.RUN){ togglePause(); }
        else if(state===STATE.PAUSE){ resume(); }
        else if(state===STATE.MENU || state===STATE.OVER){ start(); }
        updatePauseUI();
      }
    });
    addEventListener('keyup',e=>{
      if(e.code==='ArrowUp')INPUT[0].up=false;
      if(e.code==='ArrowDown')INPUT[0].down=false;
      if(e.code==='ArrowRight')INPUT[0].boost=false;
      if(e.code==='KeyW')INPUT[1].up=false;
      if(e.code==='KeyS')INPUT[1].down=false;
      if(e.code==='KeyD')INPUT[1].boost=false;
    });

    // --- MOBILE: press & hold ONLY to rise; release returns near bottom (configurable) ---
    let mobileHold=false;
    function onPointerDown(e){
      if(e.pointerType!=='touch' && !IS_MOBILE) return;
      e.preventDefault();
      mobileHold = true;
      if(IS_MOBILE && (state===STATE.MENU || state===STATE.OVER)){ start(); updatePauseUI(); }
      if(IS_MOBILE && state===STATE.PAUSE){ resume(); updatePauseUI(); }
    }
    function onPointerUp(e){
      if(e.pointerType!=='touch' && !IS_MOBILE) return;
      e.preventDefault();
      mobileHold = false;
    }
    const canvasEvents = ['pointerdown','pointerup','pointercancel','pointerleave','pointerout'];
    canvas.addEventListener('gesturestart', e=>e.preventDefault());
    canvas.addEventListener('gesturechange', e=>e.preventDefault());
    canvas.addEventListener('gestureend', e=>e.preventDefault());
    canvasEvents.forEach(type=> canvas.addEventListener(type, (type==='pointerdown'?onPointerDown:onPointerUp), {passive:false}));

    function installMascotFallback(img, name, kind, primary){
      const cands=[];
      const names=[name, (name==='Pineapple'?'Pinapple':null)].filter(Boolean);
      for(const nm of names){
        const base=`./Mascots/${nm}/${nm}`;
        if(kind==='surf'){ cands.push(`${base}Surfer.png`, `${base}Surf.png`); }
        else { cands.push(`${base}Fall.png`); }
      }
      if(primary && !cands.includes(primary)) cands.unshift(primary);
      let i=0; img.addEventListener('error', ()=>{ if(++i<cands.length) img.src=cands[i]; });
      img.src=cands[0];
    }
    class SpritePair {
      constructor(name){
        this.name=name;
        this.surf=new Image(); this.surfReady=false;
        this.fall=new Image(); this.fallReady=false;
        const p=assetsFor(name);
        this.surf.onload=()=>this.surfReady=true;
        this.fall.onload=()=>this.fallReady=true;
        installMascotFallback(this.surf, this.name, 'surf', p.surf);
        installMascotFallback(this.fall, this.name, 'fall', p.fall);
      }
    }
    function scaleFor(kind,y,img, userScale){
      const base = Math.min(0.25, Math.max(0.08, targetMascotH / ((img && img.height) || targetMascotH)));
      const mul = depthMul(kind,y);
      return base * (userScale ?? 1) * mul;
    }

    class Player{
      constructor(index,name){ this.index=index; this.name=name; this.sprites=new SpritePair(name); this.boost=0; this.alive=true; this.USER_SCALE=1; this.reset(); }
      reset(){ this.baseX = vw * (this.index===0 ? 0.22 : 0.18); this.x=this.baseX; this.y=world.seaLevel - (this.index===0?30:60); this.vy=0; this.r=16; this.roll=0; this.pumpPhase=0; this.alive=true; }
      revive(){ this.reset(); }
      setMascot(name){ this.name=name; this.sprites=new SpritePair(name); }
      update(dt){
        if(!this.alive) return;
        const accel=Number.isFinite(CFG.boost?.accel)?CFG.boost.accel:0.20;
        const decay=Number.isFinite(CFG.boost?.decay)?CFG.boost.decay:0.30;
        const pressed=INPUT[this.index].boost;
        this.boost=clamp(this.boost + (pressed?accel:-decay)*dt,0,1);

        if(IS_MOBILE){
          const holdCfg = (CFG.mobile && CFG.mobile.holdRise) || {};
          const upAccel = Number.isFinite(holdCfg.upAccel) ? holdCfg.upAccel : 800;
          const springK = Number.isFinite(holdCfg.springK) ? holdCfg.springK : 6.0;
          const damping = Number.isFinite(holdCfg.damping) ? holdCfg.damping : 3.5;
          const offset = Number.isFinite(holdCfg.baseOffsetFromBottomPx) ? holdCfg.baseOffsetFromBottomPx : 18;

          const img=this.sprites.surfReady?this.sprites.surf:null;
          const hh = img ? (img.height * scaleFor('mascot', this.y, img, this.USER_SCALE))*0.5 : 40;
          const pH = img ? img.height * scaleFor('mascot', this.y, img, this.USER_SCALE) : hh*2;
          const topOffset = pH * 0.78;
          const topPx = topLimitPx(), botPx = bottomLimitPx();
          const minY = Math.max(hh, topPx + topOffset);
          const maxY = Math.min(vh - hh, botPx - hh);
          const baseY = Math.max(minY, Math.min(maxY, maxY - offset));

          if(mobileHold){
            this.vy -= upAccel * dt;
          }else{
            const diff = (baseY - this.y);
            this.vy += diff * springK * dt;
            this.vy *= (1 - damping*dt);
          }
        }else{
          let ay=0; if(INPUT[this.index].up) ay-=700; if(INPUT[this.index].down) ay+=700;
          this.vy += ay*dt;
          const maxV=210; this.vy=clamp(this.vy,-maxV,maxV);
          if(!INPUT[this.index].up && !INPUT[this.index].down){
            if(Math.abs(this.vy) < 800*dt) this.vy=0; else this.vy -= Math.sign(this.vy)*800*dt;
          }
        }

        this.y += this.vy*dt;

        const pumpForce = Math.sin(this.pumpPhase) * 40 * this.boost;
        this.pumpPhase += (4 + 4*this.boost) * dt;
        this.y += pumpForce * 0.004 * dt;

        const img=this.sprites.surfReady?this.sprites.surf:null;
        const hw = img ? (img.width * scaleFor('mascot', this.y, img, this.USER_SCALE))*0.5 : 40;
        const farRight = vw - (hw + 8);
        const pushStrength = Number.isFinite(CFG.boost?.pushStrength) ? CFG.boost.pushStrength : 1.0;
        const moveLerp = Number.isFinite(CFG.boost?.moveLerp) ? CFG.boost.moveLerp : 1.0;
        const targetX = this.baseX + (farRight - this.baseX) * Math.max(0, Math.min(1, this.boost * pushStrength));
        this.x += (targetX - this.x) * dt * moveLerp;

        const hh = img ? (img.height * scaleFor('mascot', this.y, img, this.USER_SCALE))*0.5 : 40;
        const pH = img ? img.height * scaleFor('mascot', this.y, img, this.USER_SCALE) : hh*2;
        const topOffset = pH * 0.78;
        const topPx = topLimitPx(), botPx = bottomLimitPx();
        const minY = Math.max(hh, topPx + topOffset);
        const maxY = Math.min(vh - hh, botPx - hh);

        this.y = Math.max(Math.min(this.y, maxY), minY);

        const minXDesktop = Math.max(hw, this.baseX);
        const minXMobile  = hw + 8;
        const minX = IS_MOBILE ? minXMobile : minXDesktop;
        this.x = Math.max(Math.min(this.x, vw - hw), minX);

        this.roll += (((this.vy)*0.003 + (this.boost>0?0.12:0)) - this.roll)*dt*6;
      }
      draw(ctx){
        ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(this.roll);
        const showingFall = (!this.alive) || (state===STATE.OVER);
        const img   = showingFall ? this.sprites.fall     : this.sprites.surf;
        const ready = showingFall ? this.sprites.fallReady: this.sprites.surfReady;
        if(ready){ const s=scaleFor('mascot',this.y,img,this.USER_SCALE); const w=img.width*s, h=img.height*s; ctx.drawImage(img,-w*0.5,-h*0.78,w,h); }
        ctx.restore();
      }
    }

    // Obstacles & rest are same as earlier (omitted for brevity in this commentary)
    const activeObstacleSprites = new Set();
    const imagesLTR = [], imagesRTL = []; let bagLTR=[], bagRTL=[];
    function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } return a; }
    function refillBag(dir){ if(dir==='ltr'){ bagLTR=shuffle(imagesLTR.slice()); } else { bagRTL=shuffle(imagesRTL.slice()); } }
    function nextImageFor(dir){
      const pool = dir==='ltr'?imagesLTR:imagesRTL; if(pool.length===0) return null;
      const bag  = dir==='ltr'?bagLTR:bagRTL; if(bag.length===0) refillBag(dir);
      let tries=bag.length; while(tries--){
        const img = bag.shift();
        if(!activeObstacleSprites.has(img.src)) return img;
        bag.push(img);
      }
      return null;
    }
    function preloadObstacle(path, target){ const img=new Image(); img.onload=()=>target.push(img); img.src=path; }
    const MAX_OBS = 100;
    for(let i=1;i<=MAX_OBS;i++){ preloadObstacle(`./Obstacles/LeftToRight/Obstacle${i}.png`, imagesLTR); preloadObstacle(`./Obstacles/RightToLeft/Obstacle${i}.png`, imagesRTL); }
    const SPEED={LTR_MIN:1.05,LTR_MAX:1.20,RTL_MIN:0.70,RTL_MAX:1.10};

    class Obstacle{
      constructor(){
        const haveLTR=imagesLTR.length>0, haveRTL=imagesRTL.length>0;
        if(!haveLTR && !haveRTL){ this.valid=false; return; }
        this.dir = IS_MOBILE ? 'rtl' : ((haveLTR && haveRTL) ? (Math.random()<0.7 ? 'rtl' : 'ltr') : (haveRTL?'rtl':'ltr'));
        this.img = nextImageFor(this.dir); if(!this.img){ this.valid=false; return; }
        activeObstacleSprites.add(this.img.src);

        const topPx=topLimitPx(), botPx=bottomLimitPx();
        const midDepth = 1.0;
        const approxH = this.img.height * midDepth;
        const topOffset = approxH * 0.78;
        const minSpawnY = Math.max(topPx + topOffset, 120);
        const maxSpawnY = Math.min(vh - 60, botPx - approxH*0.5);

        const Y_GAP = 56;
        let tries=16; do{
          this.y = minSpawnY + Math.random()*Math.max(4, maxSpawnY-minSpawnY);
          tries--;
        }while(tries>0 && obstacles.some(o=>o.dir!==this.dir && Math.abs(o.y - this.y) < Y_GAP));

        this.x = (this.dir==='rtl') ? (vw + 120 + Math.random()*120) : (-120 - Math.random()*120);

        const levelMul = levelSpeedMultiplier();
        const base = (this.dir==='rtl')
          ? (SPEED.RTL_MIN + Math.random()*(SPEED.RTL_MAX - SPEED.RTL_MIN))
          : (SPEED.LTR_MIN + Math.random()*(SPEED.LTR_MAX - SPEED.LTR_MIN));
        this.factor = base * levelMul;

        this.motion = null; this.amp=0; this.freq=0; this.phase=0; this.baseY=this.y; this.vy=0;
        this.valid=true;
      }
      update(dt){
        if(!this.valid) return;
        const v = 240 * this.factor;
        this.x += (this.dir==='rtl' ? -v : v) * dt;
        if(this.motion == null){
          this.motion = (Math.random()<0.6) ? 'sine' : 'drift';
          this.amp = 10 + Math.random()*12;
          this.freq = 0.08 + Math.random()*0.10;
          this.phase = Math.random()*Math.PI*2;
          this.baseY = this.y;
          this.vy = (Math.random()<0.5?1:-1) * (4 + Math.random()*6);
        }
        if(this.motion === 'sine'){
          this.y = this.baseY + Math.sin((world.time + this.phase) * Math.PI*2 * this.freq) * this.amp;
        }else{
          this.y += this.vy * dt;
        }
      }
      off(){ return this.dir==='rtl' ? (this.x < -120) : (this.x > vw + 120); }
      cleanup(){ if(this.img){ activeObstacleSprites.delete(this.img.src); } }
      hit(player){ return false; } // (collision calc omitted in this shortened snippet)
      draw(ctx){
        if(!this.img) return;
        ctx.save(); ctx.translate(this.x,this.y);
        const depth = 1.0;
        const h = this.img.height * depth;
        const w = this.img.width  * depth;
        ctx.drawImage(this.img, -w*0.5, -h*0.78, w, h);
        ctx.restore();
      }
    }

    const STATE={MENU:0,RUN:1,PAUSE:2,OVER:3};
    let state=STATE.MENU;
    let last=0, dt=0;
    const LEVEL_SECONDS=(Number.isFinite(CFG.level?.seconds)?CFG.level.seconds:20);
    let level=1, levelElapsed=0, BANNER_DURATION=1.8, levelBannerT=0;

    function levelSpeedMultiplier(){ return Math.min(4, 1 + 0.04*(level-1)); }
    function levelSpawnInterval(){ const base=1.8, min=0.45; const t = 1 - Math.exp(-(level-1)/10); return base - (base - min) * t; }

    const players=[];
    function applyPlayerSelections(){
      if(IS_MOBILE){ setTwoPlayer(false); }
      const want2 = !IS_MOBILE && twoPlayerEnabled();
      if(players.length===0){
        players.push(new Player(0, selectedFor(0)));
        if(want2) players.push(new Player(1, selectedFor(1)));
      }else{
        if(want2 && players.length===1){ players.push(new Player(1, selectedFor(1))); }
        else if(!want2 && players.length===2){ players.pop(); }
        players[0].setMascot(selectedFor(0));
        if(players[1]) players[1].setMascot(selectedFor(1));
      }
    }
    applyPlayerSelections();
    applyUserScaleToPlayers();

    const obstacles=[]; let spawnTimer=0;
    function resetForNewGame(){
      obstacles.length=0; spawnTimer=0; levelElapsed=0;
      activeObstacleSprites.clear(); applyPlayerSelections();
      players.forEach(p=>p.revive());
      applyUserScaleToPlayers();
    }
    function maybeSpawn(dt){ spawnTimer-=dt; if(spawnTimer<=0){ const ob = new Obstacle(); if(ob.valid) obstacles.push(ob);
      const base=levelSpawnInterval(); const variance=base*0.35;
      spawnTimer=base + (Math.random()*2-1)*variance; } }
    function start(){ startMusic(); startWaves(); level=1; resetForNewGame(); state=STATE.RUN; updatePauseUI(); }
    function pause(){ if(state===STATE.RUN){ state=STATE.PAUSE; updatePauseUI(); } }
    function resume(){ if(state===STATE.PAUSE){ state=STATE.RUN; updatePauseUI(); } }
    function togglePause(){ (state===STATE.RUN)?pause():resume(); }
    function gameOver(){ state=STATE.OVER; updatePauseUI(); }

    function update(){
      levelElapsed += dt;
      players.forEach(p=>p.update(dt));
      for(const o of obstacles) o.update(dt);
      for(let i=obstacles.length-1;i>=0;i--){ if(obstacles[i].off()){ obstacles[i].cleanup(); obstacles.splice(i,1); } }
      maybeSpawn(dt);
    }

    const doho=new Image(); let dohoReady=false; doho.onload=()=>dohoReady=true; doho.src='./Background/Doho.png';

    function draw(){
      const w=1024,h=576;
      // HUD only for demo brevity
      const ctx=document.getElementById('game').getContext('2d');
      ctx.clearRect(0,0,1024,576);
      ctx.save();
      ctx.font='16px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica'; ctx.fillStyle='#fff';
      ctx.fillText(`Level: ${level}`, 16, 24);
      ctx.restore();
    }
    function loop(t){ dt=Math.min(0.033, (t-last)/1000 || 0); last=t; if(state===STATE.RUN){ update(); } draw(); requestAnimationFrame(loop); }
    updatePauseUI(); requestAnimationFrame(loop);
  })();
  </script>
</body>
</html>
