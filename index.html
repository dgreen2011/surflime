<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <!-- Lock pinch/double-tap zoom to avoid iOS magnifier, keep safe-area support -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Surf Lime</title>

  <!-- Favicons -->
  <link rel="apple-touch-icon" sizes="180x180" href="./Favicons/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="16x16"  href="./Favicons/favicon-16x16.png">
  <link rel="icon" type="image/png" sizes="32x32"  href="./Favicons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="48x48"  href="./Favicons/favicon-48x48.png">
  <link rel="icon" type="image/png" sizes="180x180" href="./Favicons/favicon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="./Favicons/android-chrome-192x192.png">
  <link rel="icon" type="image/png" sizes="512x512" href="./Favicons/android-chrome-512x512.png">

  <style>
    :root{
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-right: env(safe-area-inset-right, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --safe-left: env(safe-area-inset-left, 0px);
    }
    html,body{ margin:0; padding:0; height:100%; background:#07192c; color:#fff; font-family:ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji"; }
    *{ -webkit-tap-highlight-color: transparent; }
    body[data-ready="0"] canvas{ opacity:0 }
    body[data-ready="1"] canvas{ opacity:1; transition:opacity .22s ease }
    body[data-ready="0"] .icon-row{ opacity:0; pointer-events:none }
    body[data-ready="1"] .icon-row{ opacity:1; transition:opacity .22s ease }

    canvas{
      position:fixed; inset:0; width:100vw; height:100vh; display:block; background:#0a2846;
      touch-action:none; -ms-touch-action:none;
    }

    .icon-row{ position:fixed; top:12px; right:12px; z-index:20; display:flex; gap:10px; }
    .icon-btn{
      display:inline-flex; align-items:center; justify-content:center;
      min-width:40px; height:40px; padding:0 12px; gap:8px;
      border-radius:12px; border:1px solid #ffffff22; background:#0f233caa;
      backdrop-filter:blur(6px); cursor:pointer; color:#fff; text-decoration:none;
      font-weight:600; letter-spacing:.2px; touch-action: manipulation;
    }
    .icon-btn:hover{ background:#122c4bee }
    .icon-btn svg{ width:20px; height:20px }
    /* Hide Settings text on mobile */
    @media (pointer: coarse){ .settings-label{ display:none } }
  </style>
</head>
<body data-ready="0">
  <canvas id="game" width="1024" height="576"></canvas>

  <div class="icon-row">
    <!-- Start/Pause/Resume -->
    <button id="btnPause" class="icon-btn" title="Start" aria-label="Start">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
           stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
        <polygon points="5 3 19 12 5 21 5 3"></polygon>
      </svg>
      <span id="btnPauseLabel">Start</span>
    </button>

    <!-- Mute -->
    <button id="btnMute" class="icon-btn" title="Mute / Unmute" aria-label="Mute / Unmute">
      <svg id="iconSound" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
           stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
        <!-- speaker -->
        <path d="M11 5l-5 4H3v6h3l5 4z"></path>
        <!-- waves (toggled via class) -->
        <path id="wave1" d="M15 9a4 4 0 0 1 0 6"></path>
        <path id="wave2" d="M17 7a7 7 0 0 1 0 10"></path>
      </svg>
      <span class="settings-label">Sound</span>
    </button>

    <!-- Settings -->
    <a href="./settings.html" class="icon-btn" title="Settings" aria-label="Settings">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
           stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
        <circle cx="12" cy="12" r="3"></circle>
        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 1 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V22a2 2 0 1 1-4 0v-.09a1.65 1.65 0 0 0-1-1.51 1.65 1.65 0 0 0-1.82.33l-.06.06A2 2 0 1 1 3.4 19.4l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H2a2 2 0 1 1 0-4h.09a1.65 1.65 0 0 0 1.51-1 1.65 1.65 0 0 0-.33-1.82l-.06-.06A2 2 0 1 1 4.94 4.94l.06.06a1.65 1.65 0 0 0 1.82.33h0A1.65 1.65 0 0 0 8.33 3.82V4a2 2 0 1 1 4 0v.09a1.65 1.65 0 0 0 1 1.51h0a1.65 1.65 0 0 0 1.82-.33l.06-.06A2 2 0 1 1 20.6 4.6l-.06.06a1.65 1.65 0 0 0-.33 1.82v0A1.65 1.65 0 0 0 21 8.33H22a2 2 0 1 1 0 4h-.09a1.65 1.65 0 0 0-1.51 1Z"></path>
      </svg>
      <span class="settings-label">Settings</span>
    </a>
  </div>

  <audio id="bgm" preload="metadata" loop></audio>

  <script>
  (function(){
    'use strict';

    // ==== iOS selection/magnifier hardening (double-tap & long-press) ====
    document.addEventListener('gesturestart', e => e.preventDefault());
    document.addEventListener('dblclick', e => e.preventDefault(), { passive:false });
    // Prevent text selection highlight from game taps
    document.addEventListener('selectstart', e => e.preventDefault());
    document.addEventListener('touchstart', function(e){
      if(e.touches && e.touches.length > 1){ e.preventDefault(); }
    }, { passive:false });
    document.addEventListener('touchmove', function(e){
      if(e.touches && e.touches.length > 1){ e.preventDefault(); }
    }, { passive:false });
    (function(){
      let lastTouchEnd = 0;
      document.addEventListener('touchend', function(e){
        const now = Date.now();
        if(now - lastTouchEnd < 300){ e.preventDefault(); }
        lastTouchEnd = now;
        // Clear any stray selection ranges iOS might have created
        try{ const sel = window.getSelection && window.getSelection(); if(sel && sel.removeAllRanges) sel.removeAllRanges(); }catch(_){}
      }, { passive:false });
    })();

    const IS_MOBILE = (window.matchMedia && matchMedia('(pointer: coarse)').matches) || 'ontouchstart' in window;

    // ==== Audio (keeps music when switching pages) ====
    const music=document.getElementById('bgm');
    const K={ src:'bgmSrc', pos:'bgmPos', muted:'muted' };

    function pickMusic(){
      const m = localStorage.getItem('bgmSrc');
      if(m){ music.src = m; }
      else{
        // Default fallback
        music.src = './Audio/SurflimeTheme.mp3';
      }
    }
    pickMusic();

    // Persist position
    setInterval(()=>{
      try{
        if(music && music.currentTime && isFinite(music.currentTime)){
          localStorage.setItem(K.pos, String(music.currentTime));
        }
      }catch(_){}
    }, 1000);

    // Autoplay unlock on user gesture
    const unlock=()=>{ if(music.paused){ music.play().catch(()=>{}); } document.removeEventListener('pointerdown', unlock); };
    document.addEventListener('pointerdown', unlock, { once:true });

    // Restore mute state + icon waves
    function syncMuteUI(){
      const muted = localStorage.getItem(K.muted) === 'true';
      music.muted = muted;
      const wave1 = document.getElementById('wave1');
      const wave2 = document.getElementById('wave2');
      if(muted){ wave1.style.display = 'none'; wave2.style.display = 'none'; }
      else{ wave1.style.display = ''; wave2.style.display = ''; }
    }
    syncMuteUI();

    document.getElementById('btnMute').addEventListener('click', ()=>{
      const now = !(localStorage.getItem(K.muted) === 'true');
      localStorage.setItem(K.muted, String(now));
      syncMuteUI();
    });

    // Keep time when reloading from Settings
    window.addEventListener('pageshow', ()=>{
      syncMuteUI();
      pickMusic();
      try{ const muted = (localStorage.getItem(K.muted) === 'true'); music.muted = muted; }catch(_){}
      try{
        const v = parseFloat(localStorage.getItem(K.pos)||'0');
        if(Number.isFinite(v) && music && music.duration){ music.currentTime = Math.min(music.duration-0.2, Math.max(0,v)); }
      }catch(_){}
    });

    // ===== Canvas + game state =====
    const canvas=document.getElementById('game'); const ctx=canvas.getContext('2d',{alpha:false});
    let vw = canvas.width, vh = canvas.height, dpr=1;
    const world = { time: 0, seaLevel: 0 };
    function resizeDPR(){
      const rect = canvas.getBoundingClientRect();
      vw = Math.max(1, Math.round(rect.width));
      vh = Math.max(1, Math.round(rect.height));
      dpr = Math.max(1, window.devicePixelRatio || 1);
      canvas.width = Math.round(vw * dpr);
      canvas.height = Math.round(vh * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'medium';
      world.seaLevel = vh * 0.58;
    }
    addEventListener('resize', resizeDPR);
    addEventListener('focus', ()=>{ applyPlayerSelections(); applyUserScaleToPlayers(); updatePauseUI(); });
    addEventListener('blur', ()=>{ if(state===STATE.RUN){ pause(); updatePauseUI(); } });
    resizeDPR();
    // --- Pixel snapping helpers to reduce desktop shimmer ---
    function snap(n){ return Math.round(n * dpr) / dpr; }
    function snapSize(n){ n = Math.max(1, n); return Math.max(1, Math.round(n * dpr) / dpr); }
    function drawSpriteCrisp(ctx, img, x, y, w, h, rot=0, anchorY=0.78){
      if(!img) return;
      ctx.save();
      const sx = snap(x), sy = snap(y);
      ctx.translate(sx, sy);
      if (Math.abs(rot) > 0.001) ctx.rotate(rot);
      const W = snapSize(w), H = snapSize(h);
      const ax = Math.round(-W * 0.5 * dpr) / dpr;
      const ay = Math.round(-H * anchorY * dpr) / dpr;
      ctx.drawImage(img, ax, ay, W, H);
      ctx.restore();
    }

    function topLimitPx(){   const p=(window.SURFLIME_CONFIG?.limits?.topPercent??0.20);   return vh * Math.min(0.98, Math.max(0, p)); }
    function bottomLimitPx(){
      const p = (window.SURFLIME_CONFIG?.limits?.bottomPercent ?? 0.80);
      const desiredPx = vh * Math.min(0.999, Math.max(0, p));
      return Math.min(vh * 0.999, Math.max(topLimitPx() + 0.02*vh, desiredPx));
    }

    // Depth & scaling helpers
    function obstacleScaleMul(){
      const CFG = window.SURFLIME_CONFIG || {};
      const desk = Number.isFinite(CFG.obstacle?.scalePercent) ? CFG.obstacle.scalePercent : 100;
      const shrinkPct = Number.isFinite(CFG.mobile?.scaleDownPercent?.obstacle) ? CFG.mobile.scaleDownPercent.obstacle : null;
      const derivedMobile = Number.isFinite(CFG.obstacle?.scalePercentMobile)
        ? CFG.obstacle.scalePercentMobile
        : (shrinkPct!=null ? desk * (1 - Math.max(0,Math.min(100,shrinkPct))/100) : desk);
      const p = IS_MOBILE ? derivedMobile : desk;
      return Math.max(0.1, Math.min(3, p / 100));
    }
    function depthMul(kind,y){
      const CFG = window.SURFLIME_CONFIG || {};
      const top = topLimitPx(), bottom = bottomLimitPx();
      const t = (bottom>top) ? Math.max(0, Math.min(1, (y-top)/(bottom-top))) : 0;
      const d = CFG.depth?.[kind] || { topScale:1, bottomScale:1 };
      return (d.topScale??1) + ((d.bottomScale??1) - (d.topScale??1))*t;
    }
    function applyUserScaleToPlayers(){
      const CFG = window.SURFLIME_CONFIG || {};
      const desktop = Number.isFinite(CFG.mascot?.scale) ? CFG.mascot.scale : 1;
      const shrinkPct = Number.isFinite(CFG.mobile?.scaleDownPercent?.mascot) ? CFG.mobile.scaleDownPercent.mascot : null;
      const derivedMobile = Number.isFinite(CFG.mascot?.scaleMobile)
        ? CFG.mascot.scaleMobile
        : (shrinkPct!=null ? desktop * (1 - Math.max(0,Math.min(100,shrinkPct))/100) : desktop);
      const s = IS_MOBILE ? derivedMobile : desktop;
      (players||[]).forEach(p=> p.USER_SCALE = s);
    }

    // Players
    function assetsFor(name){
      const CFG = window.SURFLIME_CONFIG || {};
      if(CFG.mascot?.assetsFor) return CFG.mascot.assetsFor(name);
      const SURFER=new Set(['Banana','Pineapple']);
      const base=`./Mascots/${name}/${name}`;
      return { surf:`${base}${SURFER.has(name)?'Surfer':'Surf'}.png`, fall:`${base}Fall.png` };
    }
    function twoPlayerEnabled(){ return localStorage.getItem('twoPlayerEnabled') === 'true'; }
    function selectedFor(idx){
      const key = (idx===0) ? 'selectedMascotP1' : 'selectedMascotP2';
      let name = localStorage.getItem(key);
      if(!name){
        name = (idx===0) ? 'Lime' : 'Banana';
        localStorage.setItem(key, name);
        if(idx===0) localStorage.setItem('selectedMascot', name);
      }
      return name;
    }

    const targetMascotH=112;
    const INPUT = [ { up:false, down:false, boost:false }, { up:false, down:false, boost:false } ];

    addEventListener('keydown', e=>{
      if(e.code==='ArrowUp')INPUT[0].up=true;
      if(e.code==='ArrowDown')INPUT[0].down=true;
      if(e.code==='ArrowRight')INPUT[0].boost=true;
      if(e.code==='KeyW')INPUT[1].up=true;
      if(e.code==='KeyS')INPUT[1].down=true;
      if(e.code==='KeyD')INPUT[1].boost=true;
      if(e.code==='Space'){ togglePause(); }
    });
    addEventListener('keyup', e=>{
      if(e.code==='ArrowUp')INPUT[0].up=false;
      if(e.code==='ArrowDown')INPUT[0].down=false;
      if(e.code==='ArrowRight')INPUT[0].boost=false;
      if(e.code==='KeyW')INPUT[1].up=false;
      if(e.code==='KeyS')INPUT[1].down=false;
      if(e.code==='KeyD')INPUT[1].boost=false;
    });

    class SpritePair {
      constructor(name){
        this.name=name;
        this.surf=new Image(); this.surfReady=false;
        this.fall=new Image(); this.fallReady=false;
        const p=assetsFor(name);
        this.surf.onload=()=>this.surfReady=true;
        this.fall.onload=()=>this.fallReady=true;
        installMascotFallback(this.surf, this.name, 'surf', p.surf);
        installMascotFallback(this.fall, this.name, 'fall', p.fall);
      }
    }
    function installMascotFallback(img, name, key, first){
      const cands=[first, `./Mascots/${name}/${name}_${key}.png`, `./Mascots/${name}/${key}.png`].filter(Boolean);
      img.onerror=()=>{
        const tried=new Set(); tried.add(img.src);
        const next=cands.find(src=>!tried.has(src));
        if(next){ img.src=next; } else { img.onerror=null; }
      };
      img.src=cands[0];
    }
    function scaleFor(kind,y,img, userScale){
      const base = Math.min(0.25, Math.max(0.08, targetMascotH / ((img && img.height) || targetMascotH)));
      const mul = depthMul(kind,y);
      return base * (userScale ?? 1) * mul;
    }

    class Player{
      constructor(index,name){ this.index=index; this.name=name; this.sprites=new SpritePair(name); this.USER_SCALE=1; this.reset(); }
      reset(){
        this.baseX = vw * (this.index===0 ? 0.22 : 0.18);
        this.x = this.baseX;
        if(IS_MOBILE){
          const offset = Number.isFinite(window.SURFLIME_CONFIG?.mobile?.holdRise?.baseOffsetFromBottomPx) ? window.SURFLIME_CONFIG.mobile.holdRise.baseOffsetFromBottomPx : 18;
          const bot = (typeof bottomLimitPx==='function') ? bottomLimitPx() : (canvas.height*0.80);
          this.y = bot - offset;
        } else {
          this.y = world.seaLevel - (this.index===0?30:60);
        }
        this.baseY = this.y; this.vy=0; this.r=16; this.roll=0; this.pumpPhase=0; this.alive=true;
        this.boost = 0;
      }
      revive(){ this.reset(); }
      setMascot(name){
        if(this.name === name && this.sprites && this.sprites.name === name) return;
        this.name = name;
        this.sprites = new SpritePair(name);
      }
      update(dt){
        if(!this.alive) return;

        const CFG = window.SURFLIME_CONFIG || {};
        const accel=Number.isFinite(CFG.boost?.accel)?CFG.boost.accel:0.20;
        const decay=Number.isFinite(CFG.boost?.decay)?CFG.boost.decay:0.30;
        const pressed=INPUT[this.index].boost;
        this.boost=Math.max(0, Math.min(1, this.boost + (pressed?accel:-decay)*dt));

        if(IS_MOBILE){
          const upAccel  = Number.isFinite(CFG.mobile?.motion?.riseAccel)    ? CFG.mobile.motion.riseAccel    : 800;
          const springK  = Number.isFinite(CFG.mobile?.motion?.fallSpringK)  ? CFG.mobile.motion.fallSpringK  : 6.0;
          const dampCoef = Number.isFinite(CFG.mobile?.motion?.fallDamping)  ? CFG.mobile.motion.fallDamping  : 3.5;
          if(mobileHold){ this.vy -= upAccel * dt; }
          else{
            const diff = (this.baseY - this.y);
            this.vy += diff * springK * dt;
            this.vy *= (1 - Math.max(0, Math.min(10, dampCoef)) * dt);
          }
        }else{
          let ay=0; if(INPUT[this.index].up) ay-=700; if(INPUT[this.index].down) ay+=700;
          this.vy += ay*dt;
        }

        this.vy += (this.boost>0? -400: 60) * dt;
        this.y += this.vy * dt;

        const pumpForce = Math.sin(this.pumpPhase) * 40 * this.boost;
        this.pumpPhase += (4 + 4*this.boost) * dt;
        this.y += pumpForce * 0.004 * dt;

        const img=this.sprites.surfReady?this.sprites.surf:null;
        const hw = img ? (img.width * scaleFor('mascot', this.y, img, this.USER_SCALE))*0.5 : 40;
        const farRight = vw - (hw + 8);
        const pushStrength = Number.isFinite(CFG.boost?.pushStrength) ? CFG.boost.pushStrength : 1.0;
        const moveLerp = Number.isFinite(CFG.boost?.moveLerp) ? CFG.boost.moveLerp : 1.0;
        const targetX = this.baseX + (farRight - this.baseX) * Math.max(0, Math.min(1, this.boost * pushStrength));
        this.x += (targetX - this.x) * dt * moveLerp;

        const hh = img ? (img.height * scaleFor('mascot', this.y, img, this.USER_SCALE))*0.5 : 40;
        const pH = img ? img.height * scaleFor('mascot', this.y, img, this.USER_SCALE) : hh*2;
        const topOffset = pH * 0.78;
        const topPx = topLimitPx(), botPx = bottomLimitPx();
        const minY = Math.max(hh, topPx + topOffset);
        const maxY = Math.min(vh - hh, botPx - hh);

        this.y = Math.max(Math.min(this.y, maxY), minY);

        const minXDesktop = Math.max(hw, this.baseX);
        const minXMobile  = hw + 8;
        const minX = IS_MOBILE ? minXMobile : minXDesktop;
        this.x = Math.max(Math.min(this.x, vw - hw), minX);

        this.roll += (((this.vy)*0.003 + (this.boost>0?0.12:0)) - this.roll)*dt*6;
      }
      draw(ctx){
        const showingFall = (!this.alive) || (state===STATE.OVER);
        const img = showingFall ? this.sprites.fall : this.sprites.surf;
        const ready = showingFall ? this.sprites.fallReady : this.sprites.surfReady;
        if(ready){
          const s = scaleFor('mascot', this.y, img, this.USER_SCALE);
          const w = img.width * s, h = img.height * s;
          drawSpriteCrisp(ctx, img, this.x, this.y, w, h, this.roll, 0.78);
        }
      }
    }

    // Obstacles
    const activeObstacleSprites = new Set();
    const imagesLTR = [], imagesRTL = []; let bagLTR=[], bagRTL=[];
    function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } return a; }
    function refillBag(dir){ if(dir==='ltr'){ bagLTR=shuffle(imagesLTR.slice()); } else { bagRTL=shuffle(imagesRTL.slice()); } }
    function nextImageFor(dir){
      const pool = dir==='ltr'?imagesLTR:imagesRTL; if(pool.length===0) return null;
      const bag  = dir==='ltr'?bagLTR:bagRTL; if(bag.length===0) refillBag(dir);
      let tries=bag.length; while(tries--){
        const img = bag.shift();
        if(!activeObstacleSprites.has(img.src)) return img;
        bag.push(img);
      }
      return null;
    }
    function preloadObstacle(path, target){ const img=new Image(); img.onload=()=>target.push(img); img.src=path; }
    const MAX_OBS = 100;
    for(let i=1;i<=MAX_OBS;i++){ preloadObstacle(`./Obstacles/LeftToRight/Obstacle${i}.png`, imagesLTR); }
    for(let i=1;i<=MAX_OBS;i++){ preloadObstacle(`./Obstacles/RightToLeft/Obstacle${i}.png`, imagesRTL); }
    const SPEED={LTR_MIN:1.05,LTR_MAX:1.20,RTL_MIN:0.70,RTL_MAX:1.10};

    class Obstacle{
      constructor(){
        const haveLTR=imagesLTR.length>0, haveRTL=imagesRTL.length>0;
        if(!haveLTR && !haveRTL){ this.valid=false; return; }
        this.dir = IS_MOBILE ? 'rtl' : ((haveLTR && haveRTL) ? (Math.random()<0.7 ? 'rtl' : 'ltr') : (haveRTL?'rtl':'ltr'));
        this.img = nextImageFor(this.dir); if(!this.img){ this.valid=false; return; }
        activeObstacleSprites.add(this.img.src);

        const topPx=topLimitPx(), botPx=bottomLimitPx();
        const midDepth = depthMul('obstacle', (topPx+botPx)/2) * obstacleScaleMul();
        const approxH = this.img.height * midDepth;

        // Place between top/bottom zones
        const topY = topPx + approxH*0.78 + 4;
        const botY = botPx - (approxH - approxH*0.78) - 4;
        this.y = topY + Math.random() * Math.max(1, (botY - topY));

        // avoid overlapping depths when mixing LTR/RTL
        const Y_GAP = 24;
        let tries=12;
        do{
          tries--;
          if(tries<=0) break;
          if(this.dir==='rtl'){
            const base = vw + 120 + Math.random()*240;
            this.x = base;
          } else {
            const base = -120 - Math.random()*240;
            this.x = base;
          }
        }while(tries>0 && obstacles.some(o=>o.dir!==this.dir && Math.abs(o.y - this.y) < Y_GAP));

        this.x = (this.dir==='rtl') ? (vw + 120 + Math.random()*120) : (-120 - Math.random()*120);

        const levelMul = levelSpeedMultiplier();
        const base = (this.dir==='rtl')
          ? (SPEED.RTL_MIN + Math.random()*(SPEED.RTL_MAX - SPEED.RTL_MIN))
          : (SPEED.LTR_MIN + Math.random()*(SPEED.LTR_MAX - SPEED.RTL_MIN));
        this.factor = base * levelMul;

        this.motion = null; this.amp=0; this.freq=0; this.phase=0; this.baseY=this.y; this.vy=0; this.valid=true;
      }
      _enforceBounds(dt){
        const topPx=topLimitPx(), botPx=bottomLimitPx();
        const depth = depthMul('obstacle', this.y) * obstacleScaleMul();
        const h = this.img.height * depth;
        const minCenter = topPx + h*0.78 + 2;
        const maxCenter = botPx - (h - h*0.78) - 2;
        const k = 12, damp = 0.15;
        if(this.y < minCenter){
          const pen = (minCenter - this.y);
          this.y += pen * Math.min(1, k*dt);
          if(this.motion === 'drift'){ this.vy = Math.abs(this.vy||8) * (1 - damp); }
        } else if(this.y > maxCenter){
          const pen = (this.y - maxCenter);
          this.y -= pen * Math.min(1, k*dt);
          if(this.motion === 'drift'){ this.vy = -Math.abs(this.vy||8) * (1 - damp); }
        }
        if(this.motion === 'sine'){
          const safeSpan = Math.max(8, (maxCenter - minCenter) - 8);
          const maxAmp = Math.max(4, Math.min(18, safeSpan*0.45));
          if(Math.abs(this.amp) > maxAmp){ this.amp = Math.sign(this.amp) * maxAmp; }
        }
      }
      update(dt){
        if(!this.valid) return;
        const px = (this.dir==='rtl') ? -1 : 1;
        const speed = 110 * this.factor;
        this.x += px * speed * dt;

        if(!this.motion){
          this.motion = (Math.random()<0.6) ? 'sine' : 'drift';
          this.amp = 10 + Math.random()*12;
          this.freq = 0.08 + Math.random()*0.10;
          this.phase = Math.random()*Math.PI*2;
          this.baseY = this.y;
          this.vy = (Math.random()<0.5?1:-1) * (4 + Math.random()*6);
        }
        if(this.motion === 'sine'){ this.y = this.baseY + Math.sin((world.time + this.phase) * Math.PI*2 * this.freq) * this.amp; }
        else{ this.y += this.vy * dt; }
        this._enforceBounds(dt);
      }
      off(){ return this.dir==='rtl' ? (this.x < -120) : (this.x > vw + 120); }
      cleanup(){ if(this.img){ activeObstacleSprites.delete(this.img.src); } }
      hit(player){
        if(!player.alive || !this.img) return false;
        const depth = depthMul('obstacle', this.y) * obstacleScaleMul();
        const oH = this.img.height * depth;
        const oW = this.img.width  * depth;
        const oTop = this.y - oH*0.78;
        const oBottom = oTop + oH;
        const oLeft = this.x - oW*0.5;
        const oRight = this.x + oW*0.5;
        const oLowerFrac = Number.isFinite(window.SURFLIME_CONFIG?.collision?.obstacleLowerZone) ? window.SURFLIME_CONFIG.collision.obstacleLowerZone : 0.40;
        const oActiveTop = oTop + oH * (1 - oLowerFrac);
        const oActiveBottom = oBottom;
        const img = player.sprites.surfReady ? player.sprites.surf : null;
        const pH = img ? img.height * scaleFor('mascot', player.y, img, player.USER_SCALE) : 32;
        const pW = img ? img.width  * scaleFor('mascot', player.y, img, player.USER_SCALE) : 32;
        const pTop = player.y - pH*0.78;
        const pBottom = pTop + pH;
        const pLeft = player.x - pW*0.5;
        const pRight = player.x + pW*0.5;

        function shrinkLR(L, R, W){
          const trim = W * 0.16;
          return [L+trim, R-trim];
        }
        const [oL, oR] = shrinkLR(oLeft, oRight, oW);
        const [pL, pR] = shrinkLR(pLeft, pRight, pW);
        const horiz = Math.min(oR, pR) > Math.max(oL, pL);
        const vert  = Math.min(oActiveBottom, pBottom) > Math.max(oActiveTop, pTop);
        return horiz && vert;
      }
      draw(ctx){
        if(!this.img) return;
        const depth = depthMul('obstacle', this.y) * obstacleScaleMul();
        const h = this.img.height * depth;
        const w = this.img.width * depth;
        drawSpriteCrisp(ctx, this.img, this.x, this.y, w, h, 0, 0.78);
      }
    }

    // Game state & loop
    const STATE={MENU:0,RUN:1,PAUSE:2,OVER:3};
    let state=STATE.MENU;
    let last=0, dt=0;
    const LEVEL_SECONDS=(Number.isFinite(window.SURFLIME_CONFIG?.level?.seconds)?window.SURFLIME_CONFIG.level.seconds:20);
    let level=1, levelElapsed=0, BANNER_DURATION=1.8, levelBannerT=0, levelBannerText='';
    const LEVEL_MSGS = {
      2:'Nice start!', 3:'Keep it up!', 4:'Smooth moves!', 5:'Great rhythm!', 6:'Wow!',
      7:'You got this!', 8:"You're rolling!", 9:'Strong momentum!', 10:'Cruising!', 11:'Dialed in!',
      12:'On fire!', 13:'Next level!', 14:'Unstoppable!', 15:'Crushing it!', 16:'Mega flow!',
      17:'Serious skill!', 18:'Wave master!', 19:'Elite focus!', 20:'Charging hard!',
      21:'Epic form!', 22:'No limits!', 23:'Untouchable!', 24:'Beast mode!',
      25:'Absolute machine!', 26:'Unreal!', 27:'Unbelievable!', 28:'Legendary!',
      29:'Off the charts!', 30:'Champion status!'
    };
    let levelBannerSub='';

    const btnPause=document.getElementById('btnPause');
    const btnPauseLabel=document.getElementById('btnPauseLabel');
    function updatePauseUI(){
      if(state===STATE.RUN){ btnPauseLabel.textContent='Pause'; btnPause.title='Pause'; btnPause.setAttribute('aria-label','Pause'); }
      else if(state===STATE.PAUSE){ btnPauseLabel.textContent='Resume'; btnPause.title='Resume'; btnPause.setAttribute('aria-label','Resume'); }
      else if(state===STATE.MENU){ btnPauseLabel.textContent='Start'; btnPause.title='Start'; btnPause.setAttribute('aria-label','Start'); }
      else if(state===STATE.OVER){ btnPauseLabel.textContent='Restart'; btnPause.title='Restart'; btnPause.setAttribute('aria-label','Restart'); }
    }
    function pause(){ if(state===STATE.RUN){ state=STATE.PAUSE; updatePauseUI(); } }
    function resume(){ if(state===STATE.MENU || state===STATE.PAUSE || state===STATE.OVER){ if(state===STATE.MENU||state===STATE.OVER) resetForNewGame(); state=STATE.RUN; updatePauseUI(); } }
    btnPause.addEventListener('click', ()=>{ togglePause(); });
    function togglePause(){ (state===STATE.RUN)?pause():resume(); }
    function gameOver(){ state=STATE.OVER; updatePauseUI(); }

    function levelSpeedMultiplier(){ return 1 + Math.min(1.0, Math.max(0, (level-1)*0.06)); }

    function applyPlayerSelections(){
      const want2 = twoPlayerEnabled();
      if(players.length===0){
        players.push(new Player(0, selectedFor(0)));
        if(want2) players.push(new Player(1, selectedFor(1)));
      }else{
        if(want2 && players.length===1){ players.push(new Player(1, selectedFor(1))); }
        else if(!want2 && players.length===2){ players.pop(); }
        const n0 = selectedFor(0);
        if(players[0].name !== n0) players[0].setMascot(n0);
        if(players[1]){
          const n1 = selectedFor(1);
          if(players[1].name !== n1) players[1].setMascot(n1);
        }
      }
    }
    applyPlayerSelections();
    applyUserScaleToPlayers();

    // React to storage changes (mascot scale, selection, and music sync)
    window.addEventListener('storage', ()=>{
      players[0]?.setMascot(selectedFor(0));
      if(players[1]) players[1].setMascot(selectedFor(1));
      const v=parseFloat(localStorage.getItem('mascotScale'));
      if(Number.isFinite(v)){ const CFG = window.SURFLIME_CONFIG || {}; (CFG.mascot||{}); (window.SURFLIME_CONFIG.mascot||{}); window.SURFLIME_CONFIG.mascot = window.SURFLIME_CONFIG.mascot || {}; window.SURFLIME_CONFIG.mascot.scale=v; applyUserScaleToPlayers(); }
    });

    const obstacles=[]; let spawnTimer=0;
    function resetForNewGame(){
      obstacles.length=0; spawnTimer=0; levelElapsed=0;
      activeObstacleSprites.clear(); applyPlayerSelections();
      players.forEach(p=>p.revive());
      applyUserScaleToPlayers();

      last = performance.now();
    }

    function maybeSpawn(dt){
      const want = Math.max(1, Math.floor(2 + (level-1)*0.25));
      const baseInterval = 1.1;
      const interval = Math.max(0.35, baseInterval / (0.6 + (level-1)*0.05));
      spawnTimer += dt;
      if(obstacles.length < want && spawnTimer >= interval){
        const o=new Obstacle();
        if(o.valid) obstacles.push(o);
        spawnTimer = 0;
      }
    }

    const MAX_DT=1/24;
    function update(){
      levelElapsed += dt;
      players.forEach(p=>p.update(dt));
      for(const o of obstacles) o.update(dt);
      for(let i=obstacles.length-1;i>=0;i--){ if(obstacles[i].off()){ obstacles[i].cleanup(); obstacles.splice(i,1); } }
      maybeSpawn(dt);
      for(const o of obstacles){ for(const p of players){ if(o.hit(p)){ p.alive=false; } } }
      if(players.every(p=>!p.alive)){ gameOver(); }

      if(levelElapsed>=LEVEL_SECONDS){
        level++; levelElapsed = 0; levelBannerT = BANNER_DURATION;
        levelBannerText = 'LEVEL ' + level;
        if(level >= 2 && level <= 30){ levelBannerSub = LEVEL_MSGS[level] || ''; }
        else if(level > 30){ levelBannerSub = "You've arrived…"; }
        else { levelBannerSub = ''; }

        // 2-player respawn at level-up
        if(players.length > 1){
          for(const p of players){ if(!p.alive) p.revive(); }
          applyUserScaleToPlayers();
        }
      }
      if(levelBannerT>0){ levelBannerT -= dt; }
    }

    // Background image
    const doho=new Image();
    doho.src='./Background/Doho.png';

    function waitImage(img){ return new Promise(res=>{ if(img.complete) res(); else img.onload=()=>res(); }); }
    async function waitSpritePair(sp){
      await Promise.all([
        sp.surfReady ? Promise.resolve() : waitImage(sp.surf),
        sp.fallReady ? Promise.resolve() : waitImage(sp.fall)
      ]);
    }

    // Wait for first assets, then reveal everything together
    (async ()=>{
      const waits = [ waitImage(doho) ];
      if(players[0]) waits.push(waitSpritePair(players[0].sprites));
      if(players[1]) waits.push(waitSpritePair(players[1].sprites));
      await Promise.all(waits);
      document.body.setAttribute('data-ready','1');
    })();

    // Simple panel helpers
    function roundRectPath(ctx, x, y, w, h, r){
      ctx.beginPath();
      ctx.moveTo(x+r, y);
      ctx.arcTo(x+w, y,   x+w, y+h, r);
      ctx.arcTo(x+w, y+h, x,   y+h, r);
      ctx.arcTo(x,   y+h, x,   y,   r);
      ctx.arcTo(x,   y,   x+w, y,   r);
      ctx.closePath();
    }
    function drawTextPanel(text, cx, cy, font, padX=14, padY=8){
      ctx.save();
      ctx.font = font;
      const m = ctx.measureText(text);
      const w = Math.ceil(m.width) + padX*2;
      const h = Math.ceil((m.actualBoundingBoxAscent||18)+(m.actualBoundingBoxDescent||6)) + padY*2;
      const x = Math.round(cx - w/2);
      const y = Math.round(cy - h*0.66);
      ctx.globalAlpha = 0.92;
      ctx.fillStyle = '#061427cc';
      ctx.strokeStyle = '#46e38a55';
      ctx.lineWidth = 2;
      roundRectPath(ctx, x, y, w, h, 12);
      ctx.fill(); ctx.stroke();
      ctx.globalAlpha = 1;
      ctx.textAlign='center'; ctx.textBaseline='alphabetic';
      ctx.shadowColor='#000'; ctx.shadowBlur=10;
      ctx.fillStyle='#ffffff';
      ctx.fillText(text, cx, y + h - padY - 2);
      ctx.restore();
    }
    function drawCenter(title, sub){
      ctx.save();
      const cx = vw/2;
      let cy = vh/2 - 14;
      drawTextPanel(title, cx, cy, 'bold 42px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica');
      cy = vh/2 + 28;
      drawTextPanel(sub, cx, cy, '600 16px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica');
      ctx.restore();
    }

    function drawLevelBanner(){
      const w=vw, h=vh;
      const elapsed = BANNER_DURATION - levelBannerT;
      const alpha = elapsed < 0.25 ? (elapsed/0.25) : (elapsed > BANNER_DURATION-0.35 ? (BANNER_DURATION - elapsed)/0.35 : 1);

      const bw = Math.min(680, Math.round(w * 0.86));
      const bh = 124;
      const x = Math.round((w - bw)/2);
      const y = Math.round(h*0.18);

      ctx.save();
      ctx.globalAlpha = Math.max(0, alpha*0.95);
      ctx.fillStyle = '#07263fdd';
      ctx.strokeStyle = '#3fd48c88';
      ctx.lineWidth = 2;

      ctx.shadowColor = '#052b1a';
      ctx.shadowBlur = 24;
      roundRectPath(ctx, x, y, bw, bh, 18);
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.stroke();

      ctx.globalAlpha = Math.max(0,alpha);
      ctx.fillStyle = '#ffffff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.shadowColor = '#000';
      ctx.shadowBlur = 18;
      ctx.font = 'bold 56px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica';
      ctx.fillText(levelBannerText, w/2, y + bh*0.45);

      if(levelBannerSub){
        ctx.shadowBlur = 12;
        ctx.font = '600 20px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica';
        ctx.fillStyle = '#c8ffe2';
        ctx.fillText(levelBannerSub, w/2, y + bh*0.75);
      }
      ctx.restore();
    }

    function draw(){
      const w=vw,h=vh;
      ctx.clearRect(0,0,w,h);

      // Parallax background
      if(doho.complete){
        const ih = doho.naturalHeight || doho.height;
        const iw = doho.naturalWidth  || doho.width;

        const topDY  = Math.round(h*0.00);
        const midDY  = Math.round(h*0.25);
        const sandDY = Math.round(h*0.65);

        const topDH  = Math.round(h*0.45);
        const midDH  = Math.round(h*0.42);
        const sandDH = Math.round(h*0.35);

        const layers=[
          { sy:0,            sh:Math.floor(ih*.42), dy:topDY,  dh:topDH,  speed:8  },
          { sy:Math.floor(ih*.42), sh:Math.floor(ih*.38), dy:midDY,  dh:midDH,  speed:30 },
          { sy:Math.floor(ih*.80), sh:Math.floor(ih*.20), dy:sandDY, dh:sandDH, speed:30 }
        ];
        const PORTRAIT = IS_MOBILE && (window.innerHeight > window.innerWidth);
        for(const L of layers){
          if(PORTRAIT){
            const s = L.dh / L.sh;
            const tileW = Math.max(1, Math.floor(iw * s));
            const offsetPx = Math.floor((world.time * L.speed * s) % tileW);
            let x = -offsetPx;
            for(; x < w; x += tileW){
              ctx.drawImage(doho, 0, L.sy, iw, L.sh, snap(x), L.dy, tileW, L.dh);
            }
            ctx.drawImage(doho, 0, L.sy, iw, L.sh, snap(x - tileW), L.dy, tileW, L.dh);
          } else {
            const sx=Math.floor((world.time*L.speed)%iw);
            const sw1=iw-sx; const dw1=Math.floor(w*(sw1/iw));
            if(sw1>0){ ctx.drawImage(doho, sx, L.sy, sw1, L.sh, 0, L.dy, dw1, L.dh); }
            const sw2=sx; const dw2=w-dw1; if(sw2>0){ ctx.drawImage(doho, 0, L.sy, sw2, L.sh, dw1, L.dy, dw2, L.dh); }
          }
        }
      }

      const drawables=[...obstacles, ...players];
      drawables.sort((a,b)=>(a.y||0)-(b.y||0));
      for(const d of drawables){ d.draw?.(ctx); }

      // HUD
      ctx.save();
      ctx.font = '600 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica';
      ctx.fillStyle = '#ffffff';
      ctx.shadowColor='#000'; ctx.shadowBlur=8;
      const msg = (state===STATE.MENU) ? 'Press Space to Start' : (state===STATE.PAUSE ? 'Paused — Space to Resume' : (state===STATE.OVER ? 'Game Over — Space to Restart' : ''));
      if(msg){ ctx.textAlign='center'; ctx.textBaseline='top'; ctx.fillText(msg, w/2, 12); }
      ctx.textAlign='left';
      ctx.fillText('Level ' + level, 12, 12);
      ctx.restore();

      if(levelBannerT>0){ drawLevelBanner(); }
    }

    // Input (mobile hold-to-rise)
    let mobileHold=false;
    canvas.addEventListener('pointerdown', e=>{ if(IS_MOBILE){ mobileHold=true; } });
    canvas.addEventListener('pointerup',   e=>{ if(IS_MOBILE){ mobileHold=false; } });
    canvas.addEventListener('pointercancel', e=>{ if(IS_MOBILE){ mobileHold=false; } });

    const players=[];
    let levelBannerText='';

    // Main loop
    function loop(t){
      dt=Math.min(MAX_DT, (t-last)/1000 || 0);
      last=t;
      if(document.body.getAttribute('data-ready')==='1' && state===STATE.RUN){
        world.time += dt; update();
      }
      draw();
      requestAnimationFrame(loop);
    }
    updatePauseUI();
    requestAnimationFrame(loop);
  })();
  </script>
</body>
</html>
