<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Surf Lime</title>
  <style>
    :root { --bg:#0b1320; --ink:#e8f1ff; --accent:#46e38a; }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:#0b1320;color:var(--ink);font:14px/1.5 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    canvas{
      position:fixed; inset:0; width:100vw; height:100vh; display:block; background:#0a2846;
      touch-action:none; -ms-touch-action:none; user-select:none; -webkit-user-select:none;
    }
    .icon-row{ position:fixed; top:12px; right:12px; z-index:20; display:flex; gap:10px; }
    .icon-btn{
      display:inline-flex; align-items:center; justify-content:center;
      min-width:40px; height:40px; padding:0 12px; gap:8px;
      border-radius:12px; border:1px solid #ffffff22; background:#0f233caa;
      backdrop-filter:blur(6px); cursor:pointer; color:#fff; text-decoration:none;
      font-weight:600; letter-spacing:.2px;
    }
    .icon-btn:hover{ background:#122c4bee }
    .icon-btn svg{ width:20px; height:20px }
  
    /* Rotate-to-landscape overlay */
    #rotateOverlay {
      position: fixed; inset: 0;
      background: rgba(0,0,0,0.86);
      color: #fff; display: none;
      align-items: center; justify-content: center;
      text-align: center; padding: 24px; z-index: 30;
      font: 600 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    #rotateOverlay.show { display: flex; }
    #rotateOverlay .box {
      max-width: 520px; border: 1px solid #ffffff33;
      background: #0b1320e6; border-radius: 14px; padding: 18px 20px;
    }
    #rotateOverlay h2 { margin: 0 0 6px; font-size: 20px; }
    #rotateOverlay p { margin: 6px 0 0; opacity: .9; }

</style>
</head>
<body>
  <canvas id="game" width="1024" height="576"></canvas>
  <div id="rotateOverlay" aria-live="polite" aria-hidden="true">
    <div class="box">
      <h2>Rotate to landscape to play</h2>
      <p>This game needs landscape on mobile. Turn your phone sideways, then tap <strong>Fullscreen</strong> for the best view.</p>
    </div>
  </div>

  <div class="icon-row">
    <a class="icon-btn" href="settings.html" title="Settings" aria-label="Settings">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
        <path d="M12 15.5a3.5 3.5 0 1 0 0-7 3.5 3.5 0 0 0 0 7z"/>
        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 1 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 1 1-4 0v-.09a1.65 1.65 0 0 0-1-1.51 1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 1 1-2.83-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 1 1 0-4h.09a1.65 1.65 0 0 0 1.51-1 1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 1 1 2.83-2.83l.06.06a1.65 1.65 0 0 0 1.82.33h0A1.65 1.65 0 0 0 9 3.09V3a2 2 0 1 1 4 0v.09a1.65 1.65 0 0 0 1 1.51h0a1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 1 1 2.83 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82h0A1.65 1.65 0 0 0 20.91 11H21a2 2 0 1 1 0 4h-.09a1.65 1.65 0 0 0-1.51 1z"/>
      </svg>
      <span>Settings</span>
    </a>
  
    <button id="btnFS" class="icon-btn" title="Fullscreen" aria-label="Fullscreen">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
           stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
        <polyline points="15 3 21 3 21 9"></polyline>
        <polyline points="9 21 3 21 3 15"></polyline>
        <line x1="21" y1="3" x2="14" y2="10"></line>
        <line x1="3" y1="21" x2="10" y2="14"></line>
      </svg>
      <span>Fullscreen</span>
    </button>

  </div>

  <!-- Load config first -->
  <script src="config.js"></script>

<script>
(()=>{
  // ===== Mobile detect =====
  const IS_MOBILE = (window.matchMedia && matchMedia('(pointer: coarse)').matches) || 'ontouchstart' in window;

  // --- Mobile orientation block ---
  let PORTRAIT_BLOCKED = false;
  function updateOrientationBlock(){
    const landscape = window.innerWidth >= window.innerHeight;
    PORTRAIT_BLOCKED = IS_MOBILE && !landscape;
    const el = document.getElementById('rotateOverlay');
    if(el){ el.classList.toggle('show', PORTRAIT_BLOCKED); el.setAttribute('aria-hidden', PORTRAIT_BLOCKED ? 'false' : 'true'); }
    try{ if(PORTRAIT_BLOCKED && state===STATE.RUN){ pause(); } }catch(_e){}
  }
  addEventListener('resize', updateOrientationBlock);
  addEventListener('orientationchange', updateOrientationBlock);
  document.addEventListener('DOMContentLoaded', updateOrientationBlock);
  
  // --- Fullscreen controls (with iOS/webkit fallbacks) ---
  const fsBtn = document.getElementById('btnFS');
  function isFullscreenActive(){
    return !!(document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement);
  }
  function updateFSUI(){
    if(!fsBtn) return;
    // Show "Fullscreen" button only on mobile and when not already fullscreen
    fsBtn.style.display = (IS_MOBILE && !isFullscreenActive()) ? 'inline-flex' : 'none';
  }
  async function enterFullscreen(){
    const el = document.documentElement;
    const req = el.requestFullscreen || el.webkitRequestFullscreen || el.msRequestFullscreen;
    if(req){
      try{ await req.call(el); }
      catch(err){
        // iOS <16 or restricted context
        alert('Fullscreen may not be supported by your browser. On iPhone, use Share â†’ Add to Home Screen for a true full-screen experience.');
      }
    }else{
      alert('Fullscreen is not available on this device/browser.');
    }
  }
  if(fsBtn){
    fsBtn.addEventListener('click', (e)=>{ e.preventDefault(); enterFullscreen().then(updateFSUI); });
  }
  document.addEventListener('fullscreenchange', updateFSUI);
  document.addEventListener('webkitfullscreenchange', updateFSUI);
  updateFSUI();

  // --- Apply mascot scale from config.js and keep it in sync ---
  function applyUserScaleToPlayers(){
    const s = (Number.isFinite(CFG.mascot?.scale) ? CFG.mascot.scale : 1);
    (players||[]).forEach(p=> p.USER_SCALE = s);
  }


  // ===== Default to 1-Player on first load of a browser session =====
  try {
    if (!sessionStorage.getItem('SL_INIT_2P')) {
      localStorage.setItem('twoPlayerEnabled','false');
      sessionStorage.setItem('SL_INIT_2P','1');
    }
  } catch {}

  const world = { time: 0, seaLevel: 0 };

  // Canvas & DPR
  const canvas=document.getElementById('game'); const ctx=canvas.getContext('2d',{alpha:false});
  let vw = canvas.width, vh = canvas.height, dpr=1;
  function resizeDPR(){
    const rect = canvas.getBoundingClientRect();
    vw = Math.max(1, Math.round(rect.width));
    vh = Math.max(1, Math.round(rect.height));
    dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.round(vw * dpr);
    canvas.height = Math.round(vh * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    world.seaLevel = vh * 0.58;
  }
  addEventListener('resize', resizeDPR);
  addEventListener('focus', ()=>{ applyPlayerSelections();
  applyUserScaleToPlayers(); });
  resizeDPR();

  // Config helpers
  const CFG = window.SURFLIME_CONFIG || { };
  const lerp=(a,b,t)=>a+(b-a)*t;
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  function topLimitPx(){   const p=(CFG.limits?.topPercent??0.42);   return vh * Math.min(0.98, Math.max(0, p)); }
  function bottomLimitPx(){
    const p = (CFG.limits?.bottomPercent ?? 0.98);
    const desiredPx = vh * Math.min(0.999, Math.max(0, p));
    return Math.min(vh * 0.999, Math.max(topLimitPx() + 0.02*vh, desiredPx));
  }
  function obstacleScaleMul(){
    const p = Number.isFinite(CFG.obstacle?.scalePercent) ? CFG.obstacle.scalePercent : 100;
    return Math.max(0.1, Math.min(3, p / 100));
  }
  function depthMul(kind,y){
    const top = topLimitPx(), bottom = bottomLimitPx();
    const t = (bottom>top) ? clamp((y-top)/(bottom-top),0,1) : 0;
    const d = CFG.depth?.[kind] || { topScale:1, bottomScale:1 };
    return lerp(d.topScale??1, d.bottomScale??1, t);
  }

  // ===== AUDIO (mobile-safe unlock) =====
  const TRACKS = ['./Music/Surfing.mp3','./Music/Surfing2.mp3','./Music/Surfing3.mp3'];
  let music=null, waves=null, muted=false, audioUnlocked=false;

  function initMusic(){
    if(!music){
      const src = TRACKS[(Math.random()*TRACKS.length)|0];
      music = new Audio(src);
      music.loop = true;
      music.preload = 'auto';
      music.playsInline = true;
    }
  }
  function initWaves(){
    if(!waves){
      waves = new Audio();
      waves.loop = true;
      waves.preload = 'auto';
      waves.playsInline = true;
    }
  }

  // Unlock audio once on the first real user gesture
  async function unlockAudio(){
    if(audioUnlocked) return;
    audioUnlocked = true;

    initMusic(); initWaves();

    const waveVol = Number.isFinite(CFG.audio?.wavesVolume) ? CFG.audio.wavesVolume : 0.25;

    try { music.muted = true; await music.play(); } catch(_) {}

    try {
      for(const p of ['./Sfx/Waves.mp3','./Music/Waves.mp3']){
        try { waves.muted = true; waves.src = p; await waves.play(); break; } catch(_) {}
      }
    } catch(_) {}

    queueMicrotask(()=>{
      music.muted = muted; music.volume = muted ? 0 : 0.35;
      waves.muted = muted; waves.volume = muted ? 0 : waveVol;
    });
  }

  function startMusic(){
    initMusic();
    music.muted = muted;
    music.volume = muted ? 0 : 0.35;
    music.play().catch(()=>{}); // if still locked, unlockAudio will handle it
  }
  function startWaves(){
    initWaves();
    const tryPaths = ['./Sfx/Waves.mp3','./Music/Waves.mp3'];
    let i=0;
    const tryNext = async ()=>{
      if(i>=tryPaths.length) return;
      waves.src = tryPaths[i++];
      try { await waves.play(); } catch { tryNext(); }
    };
    const vol = Number.isFinite(CFG.audio?.wavesVolume) ? CFG.audio.wavesVolume : 0.25;
    waves.muted = muted;
    waves.volume = muted ? 0 : vol;
    tryNext();
  }
  function toggleMute(){
    muted=!muted;
    if(music){ music.muted = muted; music.volume = muted ? 0 : 0.35; }
    if(waves){ const vol = Number.isFinite(CFG.audio?.wavesVolume) ? CFG.audio.wavesVolume : 0.25;
      waves.muted = muted; waves.volume = muted ? 0 : vol; }
  }

  // Bind unlock to first real gesture (tap/click or key)
  document.addEventListener('pointerdown', unlockAudio, { once:true });
  document.addEventListener('keydown', unlockAudio, { once:true });

  // ===== Mascots / players =====
  function assetsFor(name){
    if(CFG.mascot?.assetsFor) return CFG.mascot.assetsFor(name);
    const SURFER=new Set(['Banana','Pineapple']);
    const base=`./Mascots/${name}/${name}`;
    return { surf:`${base}${SURFER.has(name)?'Surfer':'Surf'}.png`, fall:`${base}Fall.png` };
  }
  function twoPlayerEnabled(){ return localStorage.getItem('twoPlayerEnabled') === 'true'; }
  function setTwoPlayer(val){ localStorage.setItem('twoPlayerEnabled', val ? 'true' : 'false'); }
  function selectedFor(idx){
    const key = (idx===0) ? 'selectedMascotP1' : 'selectedMascotP2';
    let name = localStorage.getItem(key);
    if(!name){
      name = (idx===0) ? 'Lime' : 'Banana';
      localStorage.setItem(key, name);
      if(idx===0) localStorage.setItem('selectedMascot', name);
    }
    return name;
  }

  const targetMascotH=112;
  const INPUT = [ { up:false, down:false, boost:false }, { up:false, down:false, boost:false } ];

  // --- Desktop keyboard ---
  addEventListener('keydown', e=>{
    if(e.code==='ArrowUp')INPUT[0].up=true;
    if(e.code==='ArrowDown')INPUT[0].down=true;
    if(e.code==='ArrowRight')INPUT[0].boost=true;

    if(e.code==='KeyW')INPUT[1].up=true;
    if(e.code==='KeyS')INPUT[1].down=true;
    if(e.code==='KeyD')INPUT[1].boost=true;

    if(e.code==='KeyM')toggleMute();

    if(e.code==='Enter' || e.code==='NumpadEnter'){
      if(state===STATE.RUN){ togglePause(); }
      else if(state===STATE.PAUSE){ resume(); }
      else if(state===STATE.MENU || state===STATE.OVER){ start(); }
    }
  });
  addEventListener('keyup',e=>{
    if(e.code==='ArrowUp')INPUT[0].up=false;
    if(e.code==='ArrowDown')INPUT[0].down=false;
    if(e.code==='ArrowRight')INPUT[0].boost=false;

    if(e.code==='KeyW')INPUT[1].up=false;
    if(e.code==='KeyS')INPUT[1].down=false;
    if(e.code==='KeyD')INPUT[1].boost=false;
  });

  
  // --- Mobile drag-to-move (pointer events) ---
  const touchPointers = new Map();
  let draggingP1 = false;
  let dragDX = 0, dragDY = 0;

  function playerDrawBounds(p){
    const img = (p && p.sprites && p.sprites.surfReady) ? p.sprites.surf : null;
    const s = scaleFor('mascot', p.y, img, p.USER_SCALE);
    const w = img ? img.width * s : 80;
    const h = img ? img.height * s : 80;
    const left = p.x - w*0.5;
    const top  = p.y - h*0.78;
    return {l:left, t:top, r:left+w, b:top+h, w, h};
  }

  function clampPosForPlayer(p, x, y){
    const img = (p && p.sprites && p.sprites.surfReady) ? p.sprites.surf : null;
    const s = scaleFor('mascot', p.y, img, p.USER_SCALE);
    const hw = img ? (img.width * s) * 0.5 : 40;
    const hh = img ? (img.height * s) * 0.5 : 40;
    const pH = img ? (img.height * s) : (hh*2);
    const topOffset = pH * 0.78;
    const topPx = topLimitPx(), botPx = bottomLimitPx();
    const minY = Math.max(hh, topPx + topOffset);
    const maxY = Math.min(vh - hh, botPx - hh);
    const minX = hw;
    const maxX = vw - hw;
    x = Math.max(minX, Math.min(maxX, x));
    y = Math.max(minY, Math.min(maxY, y));
    return {x, y};
  }

  function onPointerDown(e){
    if(e.pointerType!=='touch' && !IS_MOBILE) return;
    e.preventDefault();
    if(PORTRAIT_BLOCKED) return;

    const p = players[0];
    if(!p){ return; }

    // Tap to start/resume if not running
    if(IS_MOBILE && (state===STATE.MENU || state===STATE.OVER)){ start(); }
    else if(IS_MOBILE && state===STATE.PAUSE){ resume(); }

    // Begin drag if the touch is on the mascot
    const rect = playerDrawBounds(p);
    const x = e.clientX, y = e.clientY;
    if(x>=rect.l && x<=rect.r && y>=rect.t && y<=rect.b){
      draggingP1 = true;
      p.isDragging = true;
      dragDX = x - p.x; dragDY = y - p.y;
      p.boost = 0; INPUT[0].up=false; INPUT[0].down=false;
    }
    touchPointers.set(e.pointerId, { });
  }
  function onPointerMove(e){
    if(!IS_MOBILE) return;
    if(!touchPointers.has(e.pointerId)) return;
    const p = players[0];
    if(!p) return;
    if(PORTRAIT_BLOCKED) return;
    if(draggingP1 && p.isDragging){
      e.preventDefault();
      const x = e.clientX - dragDX;
      const y = e.clientY - dragDY;
      const cl = clampPosForPlayer(p, x, y);
      p.x = cl.x; p.y = cl.y;
      p.vy = 0; p.boost = 0;
    }
  }
  function onPointerUp(e){
    if(!touchPointers.has(e.pointerId)) return;
    touchPointers.delete(e.pointerId);
    const p = players[0];
    if(p){
      p.isDragging = false;
      draggingP1 = false;
      // let angle settle back quickly
      p.roll = 0;
    }
  }
  // Attach to canvas only
  canvas.addEventListener('pointerdown', onPointerDown, {passive:false});
  canvas.addEventListener('pointermove', onPointerMove, {passive:false});
  addEventListener('pointerup', onPointerUp, {passive:false});
  addEventListener('pointercancel', onPointerUp, {passive:false});

  // Fallbacks for very old iOS Safari (no harm on others)
  canvas.addEventListener('gesturestart', e=>e.preventDefault());
  canvas.addEventListener('gesturechange', e=>e.preventDefault());
  canvas.addEventListener('gestureend', e=>e.preventDefault());

function installMascotFallback(img, name, kind, primary){
    const cands=[];
    const names=[name, (name==='Pineapple'?'Pinapple':null)].filter(Boolean);
    for(const nm of names){
      const base=`./Mascots/${nm}/${nm}`;
      if(kind==='surf'){ cands.push(`${base}Surfer.png`, `${base}Surf.png`); }
      else { cands.push(`${base}Fall.png`); }
    }
    if(primary && !cands.includes(primary)) cands.unshift(primary);
    let i=0; img.addEventListener('error', ()=>{ if(++i<cands.length) img.src=cands[i]; });
    img.src=cands[0];
  }

  class SpritePair {
    constructor(name){
      this.name=name;
      this.surf=new Image(); this.surfReady=false;
      this.fall=new Image(); this.fallReady=false;
      const p=assetsFor(name);
      this.surf.onload=()=>this.surfReady=true;
      this.fall.onload=()=>this.fallReady=true;
      installMascotFallback(this.surf, this.name, 'surf', p.surf);
      installMascotFallback(this.fall, this.name, 'fall', p.fall);
    }
  }
  function scaleFor(kind,y,img, userScale){
    const base = Math.min(0.25, Math.max(0.08, targetMascotH / ((img && img.height) || targetMascotH)));
    const mul = depthMul(kind,y);
    return base * (userScale ?? 1) * mul;
  }

  class Player{
    constructor(index,name){ this.index=index; this.name=name; this.sprites=new SpritePair(name); this.boost=0; this.alive=true; this.USER_SCALE=1; this.isDragging=false; this.dragTargetX=0; this.dragTargetY=0; this.reset(); }
    reset(){ this.baseX = vw * (this.index===0 ? 0.22 : 0.18); this.x=this.baseX; this.y=world.seaLevel - (this.index===0?30:60); this.vy=0; this.r=16; this.roll=0; this.pumpPhase=0; this.alive=true; }
    revive(){ this.reset(); }
    setMascot(name){ this.name=name; this.sprites=new SpritePair(name); }
    update(dt){ if(!this.alive) return;
      if(this.isDragging){
        const cl = clampPosForPlayer(this, this.dragTargetX ?? this.x, this.dragTargetY ?? this.y);
        this.x = cl.x; this.y = cl.y;
        this.vy = 0; this.boost = 0;
        this.roll += (0 - this.roll) * dt * 8;
        return;
      }
      const accel=Number.isFinite(CFG.boost?.accel)?CFG.boost.accel:0.20;
      const decay=Number.isFinite(CFG.boost?.decay)?CFG.boost.decay:0.30;
      const pressed=INPUT[this.index].boost;
      this.boost=clamp(this.boost + (pressed?accel:-decay)*dt,0,1);

      let ay=0; if(INPUT[this.index].up) ay-=700; if(INPUT[this.index].down) ay+=700;
      this.vy += ay*dt;
      const maxV=210; this.vy=clamp(this.vy,-maxV,maxV);
      if(!INPUT[this.index].up && !INPUT[this.index].down){
        if(Math.abs(this.vy) < 800*dt) this.vy=0; else this.vy -= Math.sign(this.vy)*800*dt;
      }
      this.y += this.vy*dt;

      const pumpForce = Math.sin(this.pumpPhase) * 40 * this.boost;
      this.pumpPhase += (4 + 4*this.boost) * dt;
      this.y += pumpForce * 0.004 * dt;

      const img=this.sprites.surfReady?this.sprites.surf:null;
      const hw = img ? (img.width * scaleFor('mascot', this.y, img, this.USER_SCALE))*0.5 : 40;
      const farRight = vw - (hw + 8);
      const pushStrength = Number.isFinite(CFG.boost?.pushStrength) ? CFG.boost.pushStrength : 1.0;
      const moveLerp = Number.isFinite(CFG.boost?.moveLerp) ? CFG.boost.moveLerp : 1.0;
      const targetX = this.baseX + (farRight - this.baseX) * Math.max(0, Math.min(1, this.boost * pushStrength));
      this.x += (targetX - this.x) * dt * moveLerp;

      const hh = img ? (img.height * scaleFor('mascot', this.y, img, this.USER_SCALE))*0.5 : 40;
      const pH = img ? img.height * scaleFor('mascot', this.y, img, this.USER_SCALE) : hh*2;
      const topOffset = pH * 0.78;
      const topPx = topLimitPx(), botPx = bottomLimitPx();
      const minY = Math.max(hh, topPx + topOffset);
      const maxY = Math.min(vh - hh, botPx - hh);
      this.x = Math.max(Math.min(this.x, vw - hw), Math.max(hw, this.baseX));
      this.y = Math.max(Math.min(this.y, maxY), minY);
      this.roll += (((this.vy)*0.003 + (this.boost>0?0.12:0)) - this.roll)*dt*6;
    }
    draw(ctx){
      ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(this.roll);
      const showingFall = (!this.alive) || (state===STATE.OVER);
      const img   = showingFall ? this.sprites.fall     : this.sprites.surf;
      const ready = showingFall ? this.sprites.fallReady: this.sprites.surfReady;
      if(ready){
        const s=scaleFor('mascot',this.y,img,this.USER_SCALE);
        const w=img.width*s, h=img.height*s;
        ctx.drawImage(img,-w*0.5,-h*0.78,w,h);
      } else {
        ctx.fillStyle = this.index===0 ? '#46e38a' : '#ffd166';
        ctx.beginPath(); ctx.arc(0,0,18,0,Math.PI*2); ctx.fill();
      }
      ctx.restore();
    }
  }

  // ===== Obstacles (includes smooth bounds) =====
  const activeObstacleSprites = new Set();
  const imagesLTR = [], imagesRTL = []; let bagLTR=[], bagRTL=[];
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } return a; }
  function refillBag(dir){ if(dir==='ltr'){ bagLTR=shuffle(imagesLTR.slice()); } else { bagRTL=shuffle(imagesRTL.slice()); } }
  function nextImageFor(dir){
    const pool = dir==='ltr'?imagesLTR:imagesRTL; if(pool.length===0) return null;
    const bag  = dir==='ltr'?bagLTR:bagRTL; if(bag.length===0) refillBag(dir);
    let tries=bag.length; while(tries--){
      const img = bag.shift();
      if(!activeObstacleSprites.has(img.src)) return img;
      bag.push(img);
    }
    return null;
  }
  function preloadObstacle(path, target){ const img=new Image(); img.onload=()=>target.push(img); img.src=path; }
  const MAX_OBS = 100;
  for(let i=1;i<=MAX_OBS;i++){ preloadObstacle(`./Obstacles/LeftToRight/Obstacle${i}.png`, imagesLTR); preloadObstacle(`./Obstacles/RightToLeft/Obstacle${i}.png`, imagesRTL); }
  const SPEED={LTR_MIN:1.05,LTR_MAX:1.20,RTL_MIN:0.70,RTL_MAX:1.10};

  class Obstacle{
    constructor(){
      const haveLTR=imagesLTR.length>0, haveRTL=imagesRTL.length>0;
      if(!haveLTR && !haveRTL){ this.valid=false; return; }
      this.dir = (haveLTR && haveRTL) ? (Math.random()<0.7 ? 'rtl' : 'ltr') : (haveRTL?'rtl':'ltr');
      this.img = nextImageFor(this.dir); if(!this.img){ this.valid=false; return; }
      activeObstacleSprites.add(this.img.src);

      const topPx=topLimitPx(), botPx=bottomLimitPx();
      const midDepth = depthMul('obstacle', (topPx+botPx)/2) * obstacleScaleMul();
      const approxH = this.img.height * midDepth;
      const topOffset = approxH * 0.78;
      const minSpawnY = Math.max(topPx + topOffset, 120);
      const maxSpawnY = Math.min(vh - 60, botPx - approxH*0.5);

      const Y_GAP = 56;
      let tries=16; do{
        this.y = minSpawnY + Math.random()*Math.max(4, maxSpawnY-minSpawnY);
        tries--;
      }while(tries>0 && obstacles.some(o=>o.dir!==this.dir && Math.abs(o.y - this.y) < Y_GAP));

      this.x = (this.dir==='rtl') ? (vw + 120 + Math.random()*120) : (-120 - Math.random()*120);

      const levelMul = levelSpeedMultiplier();
      const base = (this.dir==='rtl')
        ? (SPEED.RTL_MIN + Math.random()*(SPEED.RTL_MAX - SPEED.RTL_MIN))
        : (SPEED.LTR_MIN + Math.random()*(SPEED.LTR_MAX - SPEED.LTR_MIN));
      this.factor = base * levelMul;

      this.motion = null; this.amp=0; this.freq=0; this.phase=0; this.baseY=this.y; this.vy=0;
      this.valid=true;
    }

    // Smooth bounds: spring back + damping, and keep sine motion within safe envelope
    _enforceBounds(dt){
      const topPx=topLimitPx(), botPx=bottomLimitPx();
      const depth = depthMul('obstacle', this.y) * obstacleScaleMul();
      const h = this.img.height * depth;

      const minCenter = topPx + h*0.78 + 2;
      const maxCenter = botPx - (h - h*0.78) - 2;

      const k = 12;          // spring strength
      const damp = 0.15;     // velocity damping when contacting

      if(this.y < minCenter){
        const pen = (minCenter - this.y);
        this.y += pen * Math.min(1, k*dt);
        if(this.motion === 'drift'){ this.vy = Math.abs(this.vy||8) * (1 - damp); }
      } else if(this.y > maxCenter){
        const pen = (this.y - maxCenter);
        this.y -= pen * Math.min(1, k*dt);
        if(this.motion === 'drift'){ this.vy = -Math.abs(this.vy||8) * (1 - damp); }
      }

      if(this.motion === 'sine'){
        const safeSpan = Math.max(8, (maxCenter - minCenter) - 8);
        const maxAmp = Math.max(2, safeSpan * 0.45);
        if(this.amp > maxAmp) this.amp = lerp(this.amp, maxAmp, Math.min(1, 6*dt));
        this.baseY = clamp(this.baseY, minCenter + this.amp, maxCenter - this.amp);
        if(this.y <= minCenter+1 || this.y >= maxCenter-1){ this.phase += 1.5*dt; }
      }
    }

    update(dt){
      if(!this.valid) return;
      const v = 240 * this.factor;
      this.x += (this.dir==='rtl' ? -v : v) * dt;

      if(this.motion == null){
        this.motion = (Math.random()<0.6) ? 'sine' : 'drift';
        this.amp = 10 + Math.random()*12;
        this.freq = 0.08 + Math.random()*0.10;
        this.phase = Math.random()*Math.PI*2;
        this.baseY = this.y;
        this.vy = (Math.random()<0.5?1:-1) * (4 + Math.random()*6);
      }

      if(this.motion === 'sine'){
        this.y = this.baseY + Math.sin((world.time + this.phase) * Math.PI*2 * this.freq) * this.amp;
      }else{
        this.y += this.vy * dt;
      }

      this._enforceBounds(dt);
    }

    off(){ return this.dir==='rtl' ? (this.x < -120) : (this.x > vw + 120); }
    cleanup(){ if(this.img){ activeObstacleSprites.delete(this.img.src); } }

    hit(player){
      if(!player.alive || !this.img) return false;

      const depth = depthMul('obstacle', this.y) * obstacleScaleMul();
      const oH = this.img.height * depth;
      const oW = this.img.width  * depth;
      const oTop = this.y - oH*0.78;
      const oBottom = oTop + oH;
      const oLeft = this.x - oW*0.5;
      const oRight = this.x + oW*0.5;

      const oLowerFrac = Number.isFinite(CFG.collision?.obstacleLowerZone) ? CFG.collision.obstacleLowerZone : 0.40;
      const oActiveTop = oTop + oH * (1 - oLowerFrac);
      const oActiveBottom = oBottom;

      const img = player.sprites.surfReady ? player.sprites.surf : null;
      const pH = img ? img.height * scaleFor('mascot', player.y, img, player.USER_SCALE) : player.r*2;
      const pW = img ? img.width  * scaleFor('mascot', player.y, img, player.USER_SCALE) : player.r*2;
      const pTop = player.y - pH*0.78;
      const pBottom = pTop + pH;
      const pLeft  = player.x - pW*0.5;
      const pRight = player.x + pW*0.5;

      const pLowerFrac = Number.isFinite(CFG.collision?.limeLowerZone) ? CFG.collision.limeLowerZone : 0.40;
      const pActiveTop = pTop + pH * (1 - pLowerFrac);
      const pActiveBottom = pBottom;

      const shrinkLR = (L, R, W) => { const pad = W * 0.08 * 0.5; return [L + pad, R - pad]; };
      const [oL, oR] = shrinkLR(oLeft, oRight, oW);
      const [pL, pR] = shrinkLR(pLeft, pRight, pW);

      const horiz = Math.min(oR, pR) > Math.max(oL, pL);
      const vert  = Math.min(oActiveBottom, pActiveBottom) > Math.max(oActiveTop, pActiveTop);
      return horiz && vert;
    }

    draw(ctx){
      if(!this.img) return;
      ctx.save(); ctx.translate(this.x,this.y);
      const depth = depthMul('obstacle', this.y) * obstacleScaleMul();
      const h = this.img.height * depth;
      const w = this.img.width  * depth;
      ctx.drawImage(this.img, -w*0.5, -h*0.78, w, h);
      ctx.restore();
    }
  }

  // ===== Infinite levels, no resets between levels =====
  const STATE={MENU:0,RUN:1,PAUSE:2,OVER:3};
  let state=STATE.MENU;
  let last=0, dt=0;
  const LEVEL_SECONDS=(Number.isFinite(CFG.level?.seconds)?CFG.level.seconds:20);
  let level=1, levelElapsed=0, BANNER_DURATION=1.8, levelBannerT=0, levelBannerText='';

  function levelSpeedMultiplier(){ return Math.min(4, 1 + 0.04*(level-1)); }
  function levelSpawnInterval(){ const base=1.8, min=0.45; const t = 1 - Math.exp(-(level-1)/10); return base - (base - min) * t; }

  const players=[];
  function applyPlayerSelections(){
    // Force 1P on mobile
    if(IS_MOBILE){ setTwoPlayer(false); }
    const want2 = !IS_MOBILE && twoPlayerEnabled();
    if(players.length===0){
      players.push(new Player(0, selectedFor(0)));
      if(want2) players.push(new Player(1, selectedFor(1)));
    }else{
      if(want2 && players.length===1){ players.push(new Player(1, selectedFor(1))); }
      else if(!want2 && players.length===2){ players.pop(); }
      players[0].setMascot(selectedFor(0));
      if(players[1]) players[1].setMascot(selectedFor(1));
    }
  }
  applyPlayerSelections();
  window.addEventListener('storage', (e)=>{
    players[0]?.setMascot(selectedFor(0));
    if(players[1]) players[1].setMascot(selectedFor(1));
    if(e.key==='mascotScale'){ const v=parseFloat(localStorage.getItem('mascotScale')); if(Number.isFinite(v)){ CFG.mascot = CFG.mascot||{}; CFG.mascot.scale=v; applyUserScaleToPlayers(); } }
  });

  const obstacles=[]; let spawnTimer=0;
  function resetForNewGame(){
    obstacles.length=0; spawnTimer=0; levelElapsed=0;
    activeObstacleSprites.clear(); applyPlayerSelections();
    players.forEach(p=>p.revive());
  }
  function maybeSpawn(dt){
    spawnTimer-=dt;
    if(spawnTimer<=0){
      const ob = new Obstacle(); if(ob.valid) obstacles.push(ob);
      const base=levelSpawnInterval(); const variance=base*0.35;
      spawnTimer=base + (Math.random()*2-1)*variance;
    }
  }

  function start(){ startMusic(); startWaves(); level=1; resetForNewGame(); state=STATE.RUN; }
  function pause(){ if(state===STATE.RUN){ state=STATE.PAUSE; } }
  function resume(){ if(state===STATE.PAUSE){ state=STATE.RUN; } }
  function togglePause(){ (state===STATE.RUN)?pause():resume(); }
  function gameOver(){ state=STATE.OVER; }

  function update(){
    levelElapsed += dt;
    players.forEach(p=>p.update(dt));
    for(const o of obstacles) o.update(dt);
    for(let i=obstacles.length-1;i>=0;i--){ if(obstacles[i].off()){ obstacles[i].cleanup(); obstacles.splice(i,1); } }
    maybeSpawn(dt);
    for(const o of obstacles){ for(const p of players){ if(o.hit(p)){ p.alive=false; } } }
    if(players.every(p=>!p.alive)){ gameOver(); }

    if(levelElapsed>=LEVEL_SECONDS){
      level++;
      levelElapsed = 0;
      levelBannerT = BANNER_DURATION; levelBannerText = 'LEVEL ' + level;
    }
    if(levelBannerT>0){ levelBannerT -= dt; }
  }

  // Background + readable overlays
  const doho=new Image(); let dohoReady=false; doho.onload=()=>dohoReady=true; doho.src='./Background/Doho.png';
  function drawBG(ctx,w,h,t){
    if(dohoReady){
      const iw=doho.width, ih=doho.height;
      const topDY = 0, topDH = Math.floor(h*0.42);
      const midDY = Math.floor(h*0.42), midDH = Math.floor(h*0.38) + 2;
      const sandDY = Math.floor(h*0.80) - 2, sandDH = Math.ceil(h*0.20) + 4;
      const layers=[
        { sy:0,            sh:Math.floor(ih*.42), dy:topDY,  dh:topDH,  speed:8  },
        { sy:Math.floor(ih*.42), sh:Math.floor(ih*.38), dy:midDY,  dh:midDH,  speed:30 },
        { sy:Math.floor(ih*.80), sh:Math.floor(ih*.20), dy:sandDY, dh:sandDH, speed:30 }
      ];
      for(const L of layers){
        const sx=Math.floor((t*L.speed)%iw);
        const sw1=iw-sx; const dw1=Math.floor(w*(sw1/iw));
        if(sw1>0){ ctx.drawImage(doho, sx, L.sy, sw1, L.sh, 0, L.dy, dw1, L.dh); }
        const sw2=sx, dw2=w-dw1;
        if(sw2>0&&dw2>0){ ctx.drawImage(doho, 0, L.sy, sw2, L.sh, dw1, L.dy, dw2, L.dh); }
      }
      return;
    }
    const grad=ctx.createLinearGradient(0,world.seaLevel-100,0,h);
    grad.addColorStop(0,'#1875c2'); grad.addColorStop(1,'#0d467b');
    ctx.fillStyle=grad; ctx.fillRect(0,world.seaLevel-100,w,h-(world.seaLevel-100));
  }

  function roundRectPath(ctx, x, y, w, h, r){
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y,   x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x,   y+h, r);
    ctx.arcTo(x,   y+h, x,   y,   r);
    ctx.arcTo(x,   y,   x+w, y,   r);
    ctx.closePath();
  }
  function drawTextPanel(text, cx, cy, font, padX=14, padY=8){
    ctx.save();
    ctx.font = font;
    const m = ctx.measureText(text);
    const w = Math.ceil(m.width) + padX*2;
    const h = Math.ceil((m.actualBoundingBoxAscent||18)+(m.actualBoundingBoxDescent||6)) + padY*2;
    const x = Math.round(cx - w/2);
    const y = Math.round(cy - h*0.66);
    ctx.globalAlpha = 0.92;
    ctx.fillStyle = '#061427cc';
    ctx.strokeStyle = '#46e38a55';
    ctx.lineWidth = 2;
    roundRectPath(ctx, x, y, w, h, 12);
    ctx.fill(); ctx.stroke();
    ctx.globalAlpha = 1;
    ctx.textAlign='center'; ctx.textBaseline='alphabetic';
    ctx.shadowColor='#000'; ctx.shadowBlur=10;
    ctx.fillStyle='#ffffff';
    ctx.fillText(text, cx, y + h - padY - 2);
    ctx.restore();
  }
  function drawCenter(title, sub){
    ctx.save();
    const cx = vw/2;
    let cy = vh/2 - 14;
    drawTextPanel(title, cx, cy, 'bold 42px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica');
    cy = vh/2 + 28;
    drawTextPanel(sub, cx, cy, '600 16px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica');
    ctx.restore();
  }
  function drawLevelBanner(){
    const w=vw, h=vh;
    const elapsed = BANNER_DURATION - levelBannerT;
    const alpha = elapsed < 0.25 ? (elapsed/0.25) : (elapsed > BANNER_DURATION-0.35 ? (BANNER_DURATION - elapsed)/0.35 : 1);
    const bw = Math.min(680, Math.floor(w*0.72));
    const bh = 120;
    const bannerY = (CFG.ui?.levelBannerYPercent ?? 0.18);
    const x = (w-bw)/2, y = h * bannerY;
    ctx.save();
    ctx.globalAlpha = 0.75 * Math.max(0,alpha);
    ctx.fillStyle = '#061427';
    ctx.strokeStyle = '#46e38a';
    ctx.lineWidth = 3;
    roundRectPath(ctx, x, y, bw, bh, 16);
    ctx.fill(); ctx.stroke();
    ctx.globalAlpha = Math.max(0,alpha);
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 52px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.shadowColor = '#000';
    ctx.shadowBlur = 18;
    ctx.fillText(levelBannerText, w/2, y+bh/2);
    ctx.restore();
  }

  function draw(){
    const w=vw,h=vh;
    ctx.clearRect(0,0,w,h);
    drawBG(ctx,w,h,world.time);

    const drawables=[...obstacles, ...players];
    drawables.sort((a,b)=>(a.y||0)-(b.y||0));
    for(const d of drawables){ d.draw?.(ctx); }

    // HUD
    ctx.save();
    ctx.font='16px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica';
    ctx.fillStyle='#fff';
    ctx.fillText(`Level ${level}`,16,26);
    const remain=Math.ceil(Math.max(0,LEVEL_SECONDS-levelElapsed));
    ctx.fillText(`Time: ${String(Math.floor(remain/60)).padStart(2,'0')}:${String(remain%60).padStart(2,'0')}`,16,48);
    if(!IS_MOBILE && twoPlayerEnabled()){
      ctx.fillStyle='#b9ffd7'; ctx.fillText(`P1: ${players[0]?.name||'-'}`,16,72);
      ctx.fillStyle='#ffe399'; ctx.fillText(`P2: ${players[1]?.name||'-'}`,16,92);
    }else{
      ctx.fillStyle='#b9ffd7'; ctx.fillText(`Mascot: ${players[0]?.name||'-'}`,16,72);
    }
    ctx.restore();

    // Overlays (mobile has "Tap" copy)
    if(state===STATE.MENU){ drawCenter('Surf Lime', IS_MOBILE?'Tap to Start':'Press Enter to Start'); }
    if(state===STATE.PAUSE){ drawCenter('Paused', IS_MOBILE?'Tap to Resume':'Press Enter to Resume'); }
    if(state===STATE.OVER){ drawCenter('Wipeout!', IS_MOBILE?'Tap to Play Again':'Press Enter to Play Again'); }
    if(levelBannerT>0){ drawLevelBanner(); }
  }

  function loop(t){
    dt=Math.min(0.033, (t-last)/1000 || 0);
    last=t;
    if(state===STATE.RUN){ world.time += dt; update(); }
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
